<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Twin Lakes Ranch ‚Äî Interactive Plat Map</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:#0d1117;color:#c9d1d9;overflow:hidden;height:100vh;height:100dvh}
#app{display:flex;height:100vh;height:100dvh}

/* === PANELS (shared) === */
.panel{
  width:260px;min-width:260px;background:#161b22;
  display:flex;flex-direction:column;z-index:10;
}
.panel-l{border-right:1px solid #30363d}
.panel-r{border-left:1px solid #30363d}
.panel-hdr{padding:10px 12px;background:#0d1117;border-bottom:1px solid #30363d;cursor:pointer;user-select:none}
.panel-hdr h2{font-size:12px;font-weight:700;letter-spacing:0.3px;margin-bottom:1px;display:flex;align-items:center;justify-content:space-between}
.panel-hdr h2::after{content:'‚ñæ';font-size:10px;color:#8b949e}
.panel-hdr .sub{font-size:9px;color:#8b949e;line-height:1.3}

#title-bar{padding:10px 12px;background:#0d1117;border-bottom:1px solid #30363d}
#title-bar h1{font-size:13px;font-weight:700;color:#58a6ff;letter-spacing:0.3px;margin-bottom:1px}
#title-bar .subtitle{font-size:9px;color:#8b949e;line-height:1.3}
#title-bar .org{font-size:10px;color:#7ee787;font-weight:600;margin-top:4px;display:flex;align-items:center;gap:4px}
#title-bar .org::before{content:'';display:inline-block;width:6px;height:6px;background:#7ee787;border-radius:50%}

.search-wrap{padding:6px 10px;border-bottom:1px solid #30363d}
.search-wrap input{
  width:100%;padding:6px 8px;border-radius:5px;border:1px solid #30363d;
  background:#0d1117;color:#c9d1d9;font-size:11px;outline:none;
}
.search-wrap input:focus{border-color:#58a6ff}
.search-wrap input::placeholder{color:#484f58}

.filter-area{padding:6px 10px;border-bottom:1px solid #30363d}
.filter-area h3{font-size:9px;color:#8b949e;text-transform:uppercase;letter-spacing:0.6px;margin-bottom:4px}
.chips{display:flex;flex-wrap:wrap;gap:2px}
.chip{
  padding:2px 7px;border-radius:9px;font-size:9px;font-weight:600;
  cursor:pointer;border:2px solid #30363d;background:#21262d;color:#c9d1d9;
  transition:all .12s;white-space:nowrap;
}
.chip:hover{opacity:0.85}
.chip.on{color:#fff}

.item-list{flex:1;overflow-y:auto;padding:2px 4px}
.item-list::-webkit-scrollbar{width:4px}
.item-list::-webkit-scrollbar-track{background:#161b22}
.item-list::-webkit-scrollbar-thumb{background:#30363d;border-radius:3px}

.panel-stats{padding:5px 10px;border-top:1px solid #30363d;font-size:9px;color:#8b949e;display:flex;justify-content:space-between}

/* Lot items */
.li{
  padding:5px 8px;margin:1px 0;border-radius:4px;cursor:pointer;
  transition:all .1s;border-left:3px solid transparent;
  display:flex;align-items:center;font-size:11px;gap:5px;
}
.li:hover{background:#21262d;border-left-color:#58a6ff}
.li.act{background:#1c2333;border-left-color:#58a6ff}
.li .num{font-weight:700;color:#58a6ff;min-width:36px}
.li .ac{color:#7ee787;font-size:9px;min-width:32px;text-align:right}
.li .owner{font-size:9px;color:#8b949e;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.li .sheet-badge{font-size:8px;color:#d29922;margin-left:auto}

/* Point items */
.pi{
  padding:4px 8px;margin:1px 0;border-radius:4px;cursor:pointer;
  transition:all .1s;border-left:3px solid transparent;
  display:flex;align-items:center;font-size:11px;gap:5px;
}
.pi:hover{background:#21262d}
.pi.act{background:#1c2333}
.pi .plabel{font-weight:700;min-width:28px}
.pi .pdesc{flex:1;color:#8b949e;font-size:9px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.pi .sheet-badge{font-size:8px;color:#d29922;margin-left:auto}

.grp-hdr{
  padding:3px 8px;margin-top:5px;font-size:9px;font-weight:800;
  text-transform:uppercase;letter-spacing:0.6px;display:flex;align-items:center;gap:5px;
}
.grp-dot{width:8px;height:8px;border-radius:50%}

/* === MAP === */
#map{flex:1;position:relative;overflow:hidden;background:#d5d0c4;cursor:grab;touch-action:none}
#map.drag{cursor:grabbing}
#map.tool-pen,#map.tool-hl{cursor:crosshair}
#map.tool-text{cursor:text}
#map.tool-dot{cursor:cell}
#map.tool-move{cursor:default}
#map.tool-eraser{cursor:none}
#map.tool-screenshot{cursor:crosshair}
#map.tool-measure{cursor:crosshair}
#sel-rect{position:absolute;border:2px dashed #58a6ff;background:rgba(88,166,255,0.08);pointer-events:none;display:none;z-index:7;border-radius:2px}
.tb svg{width:16px;height:16px;pointer-events:none;flex-shrink:0}
#wrap{position:absolute;top:0;left:0;transform-origin:0 0}
#img{display:block;user-select:none;-webkit-user-drag:none}
#svg{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
#draw-svg{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
#draw-svg.interactive{pointer-events:all}
#draw-svg.interactive *{pointer-events:all;cursor:grab}
#draw-svg.interactive .dragging{cursor:grabbing}
/* eraser pointer-events handled via JS inline styles */

/* Eraser cursor circle */
#eraser-cursor{
  position:absolute;pointer-events:none;z-index:9;display:none;
  border:2px solid rgba(255,255,255,0.8);border-radius:50%;
  box-shadow:0 0 0 1px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(0,0,0,0.15);
  transform:translate(-50%,-50%);
  transition:width 0.15s, height 0.15s;
}
/* Eraser stamp circles */
.eraser-stamp{
  position:absolute;pointer-events:none;z-index:8;border-radius:50%;
  background:rgba(255,255,255,0.35);
  transform:translate(-50%,-50%);
  animation:eraser-fade 0.6s ease-out forwards;
}
@keyframes eraser-fade{
  0%{opacity:1;transform:translate(-50%,-50%) scale(1)}
  100%{opacity:0;transform:translate(-50%,-50%) scale(0.85)}
}

/* Lot circle indicator */
@keyframes pulse{0%,100%{r:22;opacity:0.9}50%{r:30;opacity:0.5}}
.lot-dot{fill:rgba(255,200,0,0.5);stroke:#ffd700;stroke-width:3;pointer-events:none}
.lot-dot.show{animation:pulse 1.6s ease-in-out infinite}
.lot-label{font-size:16px;font-weight:800;fill:#1a1a2e;text-anchor:middle;pointer-events:none;
  paint-order:stroke;stroke:#fff;stroke-width:4px;dominant-baseline:central;opacity:0;transition:opacity .15s}
.lot-label.show{opacity:1}

/* Road point markers */
@keyframes ptpulse{0%,100%{r:14;opacity:0.95}50%{r:20;opacity:0.6}}
.rp-dot{stroke:#fff;stroke-width:2;opacity:0.85;pointer-events:none;transition:opacity .15s}
.rp-dot.dim{opacity:0.2}
.rp-dot.hi{animation:ptpulse 1.4s ease-in-out infinite;opacity:1;stroke-width:3}
.rp-label{font-size:11px;font-weight:800;fill:#fff;text-anchor:middle;pointer-events:none;
  paint-order:stroke;stroke:rgba(0,0,0,0.7);stroke-width:3px;dominant-baseline:central;transition:opacity .15s}
.rp-label.dim{opacity:0.15}
.rp-label.hi{opacity:1;font-size:14px}

/* === TOOLBAR === */
#toolbar{
  position:absolute;top:8px;left:50%;transform:translateX(-50%);z-index:6;
  display:flex;flex-wrap:wrap;justify-content:center;gap:2px;
  background:#161b22;border:1px solid #30363d;border-radius:8px;padding:3px 3px 1px;
  max-width:calc(100% - 90px);align-items:flex-start;
}
.tb{
  width:32px;min-height:32px;border-radius:6px;border:none;
  background:transparent;color:#8b949e;font-size:15px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;transition:all .1s;
  position:relative;flex-shrink:0;flex-direction:column;gap:0;padding:4px 0 0;
}
.tb-tip{font-size:7px;color:#6e7681;line-height:1;pointer-events:none;letter-spacing:0.2px;margin-top:1px}
.tb:hover{background:#21262d;color:#c9d1d9}
.tb.on{background:#1f6feb;color:#fff;box-shadow:0 0 0 2px #58a6ff,0 2px 8px rgba(31,111,235,0.5)}
.tb-sep{width:1px;background:#30363d;margin:4px 1px;flex-shrink:0}
.tb input[type="color"]{
  position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%;
}
.tb .color-preview{width:16px;height:16px;border-radius:3px;border:2px solid #8b949e;pointer-events:none}
#stroke-size{
  width:44px;height:28px;border-radius:4px;border:1px solid #30363d;
  background:#0d1117;color:#c9d1d9;font-size:10px;text-align:center;
  padding:0 2px;outline:none;flex-shrink:0;
}
#stroke-size:focus{border-color:#58a6ff}
.tb-label{font-size:8px;color:#8b949e;display:flex;align-items:center;padding:0 3px;flex-shrink:0}

/* === CONTROLS (zoom) === */
#ctrls{position:absolute;top:8px;right:8px;z-index:5;display:flex;flex-direction:column;gap:2px}
.cb{
  width:32px;height:32px;border-radius:6px;border:1px solid #30363d;
  background:#161b22;color:#c9d1d9;font-size:15px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;transition:all .1s;
}
.cb:hover{background:#21262d;border-color:#58a6ff;color:#58a6ff}

/* === INFO PANEL === */
#info{
  position:absolute;bottom:0;left:0;right:0;z-index:8;
  background:#161b22;border-top:2px solid #58a6ff;
  transform:translateY(100%);transition:transform .2s ease;
  max-height:35vh;overflow-y:auto;
}
#info.show{transform:translateY(0)}
#info-head{
  display:flex;justify-content:space-between;align-items:center;
  padding:10px 16px;border-bottom:1px solid #30363d;
  position:sticky;top:0;background:#161b22;
}
#info-t{font-size:15px;font-weight:700;color:#58a6ff}
#info-x{
  width:24px;height:24px;border-radius:4px;border:1px solid #30363d;
  background:transparent;color:#8b949e;cursor:pointer;font-size:13px;
  display:flex;align-items:center;justify-content:center;
}
#info-x:hover{background:#21262d;color:#f85149}
#info-b{padding:10px 16px;display:flex;flex-wrap:wrap;gap:10px}
.ic{background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;min-width:140px;flex:1}
.ic-l{font-size:8px;text-transform:uppercase;letter-spacing:0.6px;color:#8b949e;margin-bottom:2px}
.ic-v{font-size:13px;font-weight:600;color:#c9d1d9}
.ic-v.grn{color:#7ee787}.ic-v.blu{color:#58a6ff}.ic-v.ylw{color:#d29922}
.in{width:100%;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px}
.in h4{font-size:9px;color:#8b949e;text-transform:uppercase;letter-spacing:0.4px;margin-bottom:3px}
.in p{font-size:11px;color:#c9d1d9;line-height:1.4}
#info::-webkit-scrollbar{width:4px}
#info::-webkit-scrollbar-track{background:#161b22}
#info::-webkit-scrollbar-thumb{background:#30363d;border-radius:3px}

/* TOAST */
#toast{
  position:absolute;bottom:10px;left:50%;transform:translateX(-50%) translateY(50px);
  z-index:20;background:#1f6feb;color:#fff;padding:6px 12px;
  border-radius:6px;font-size:11px;font-weight:600;transition:transform .25s;pointer-events:none;
  white-space:nowrap;
}
#toast.show{transform:translateX(-50%) translateY(0)}

/* === ANNOTATION COUNT BADGE === */
#anno-count{
  position:absolute;bottom:10px;right:10px;z-index:5;
  background:#161b22;border:1px solid #30363d;border-radius:6px;
  padding:4px 10px;font-size:10px;color:#8b949e;display:none;
}
#anno-count.show{display:block}

/* === RESPONSIVE === */
@media(max-width:1000px){
  .panel{width:200px;min-width:200px}
}
@media(max-width:760px){
  #app{flex-direction:column;position:relative}

  /* === MOBILE TABBED PANEL === */
  #mobile-tabs{
    display:flex;position:absolute;top:0;left:0;right:0;z-index:16;
    background:#0d1117;border-bottom:1px solid #30363d;
  }
  #mobile-tabs .mtab{
    flex:1;padding:8px 6px;text-align:center;font-size:10px;font-weight:700;
    letter-spacing:0.3px;color:#8b949e;cursor:pointer;border:none;background:transparent;
    border-bottom:2px solid transparent;transition:all .15s;
  }
  #mobile-tabs .mtab.active{color:#58a6ff;border-bottom-color:#58a6ff;background:#161b22}
  #mobile-tabs .mtab:nth-child(2).active{color:#f97316;border-bottom-color:#f97316}

  /* Panels become overlaid drawers below the tabs */
  .panel{
    width:100%;min-width:100%;border-right:none!important;border-left:none!important;
    border-bottom:1px solid #30363d;
    position:absolute;left:0;right:0;z-index:15;
    top:36px;
    max-height:0;overflow:hidden;
    transition:max-height .2s ease;
  }
  .panel.mobile-active{max-height:28vh;overflow-y:auto}
  .panel.mobile-active .item-list{max-height:calc(28vh - 44px);overflow-y:auto}
  #right-panel{top:36px;bottom:auto;border-top:none}

  /* Hide elements not needed on mobile */
  .panel-hdr{display:none}
  #title-bar{display:none}
  .panel-stats{display:none!important}
  .filter-area{display:none!important}
  .panel .sub{display:none}

  /* Compact search on mobile */
  .search-wrap{padding:4px 8px;border-bottom:1px solid #30363d}
  .search-wrap input{padding:5px 7px;font-size:10px}

  /* Hide old collapsed styles */
  .panel.collapsed{max-height:0;overflow:hidden}

  /* Compact toolbar along left side */
  #toolbar{
    top:50%;right:auto;left:6px;transform:translateY(-50%);
    flex-direction:column;max-width:36px!important;
    padding:3px 2px;gap:1px;border-radius:6px;
    align-items:center;
  }
  .tb{width:28px;min-height:28px;font-size:12px;padding:2px 0}
  .tb-tip{display:none}
  .tb-sep{width:80%;height:1px;margin:1px 0}
  .tb-label{display:none}
  #stroke-size{display:none}
  #ctrls{top:auto;bottom:50px;right:6px}
  .cb{width:28px;height:28px;font-size:13px}
  #legend-panel{left:4px;bottom:4px;width:180px}
  #measure-info{top:auto;bottom:10px;left:50%;font-size:10px}
  #minimap{width:80px;height:108px;top:42px;left:6px}
  #coord-display{bottom:6px;font-size:9px;padding:2px 6px}
  .coord-input{width:36px;font-size:9px}
  #share-view-btn{display:none}
}
@media(max-width:420px){
  .tb-label{display:none}
  #stroke-size{display:none}
}
/* Hide mobile tabs on desktop */
#mobile-tabs{display:none}

/* === WELCOME MODAL === */
#modal-overlay{
  position:fixed;inset:0;z-index:999;
  background:rgba(0,0,0,0.85);
  display:flex;align-items:center;justify-content:center;
  padding:20px;
  opacity:1;transition:opacity .3s;
  overflow-y:auto;-webkit-overflow-scrolling:touch;
}
#modal-overlay.hidden{opacity:0;pointer-events:none}
#modal-overlay.no-backdrop{background:rgba(0,0,0,0.25);backdrop-filter:none}
#modal{
  background:#161b22;border:1px solid #30363d;border-radius:12px;
  max-width:580px;width:100%;
  box-shadow:0 20px 60px rgba(0,0,0,0.5);
  display:flex;flex-direction:column;
  max-height:90vh;
}
#modal::-webkit-scrollbar{width:4px}
#modal::-webkit-scrollbar-thumb{background:#30363d;border-radius:3px}
.modal-top{
  padding:24px 28px 16px;border-bottom:1px solid #30363d;text-align:center;flex-shrink:0;
}
.modal-top .logo{font-size:20px;font-weight:800;color:#58a6ff;margin-bottom:2px;letter-spacing:0.3px}
.modal-top .org-tag{font-size:11px;color:#7ee787;font-weight:600;display:inline-flex;align-items:center;gap:5px}
.modal-top .org-tag::before{content:'';width:6px;height:6px;background:#7ee787;border-radius:50%;display:inline-block}
.modal-body{padding:20px 28px;overflow-y:auto;flex:1;-webkit-overflow-scrolling:touch}
.modal-body h3{font-size:13px;font-weight:700;color:#58a6ff;margin:14px 0 6px;display:flex;align-items:center;gap:6px}
.modal-body h3:first-child{margin-top:0}
.modal-body p{font-size:12px;color:#c9d1d9;line-height:1.6;margin-bottom:8px}
.modal-body .note{
  font-size:11px;color:#d29922;background:rgba(210,153,34,0.1);
  border:1px solid rgba(210,153,34,0.25);border-radius:6px;
  padding:8px 12px;margin-top:12px;line-height:1.5;
}
.modal-footer{
  padding:16px 28px 24px;display:flex;flex-wrap:wrap;justify-content:center;
  flex-shrink:0;border-top:1px solid #30363d;background:#161b22;
  border-radius:0 0 12px 12px;
}
#modal-continue{
  padding:10px 40px;border-radius:8px;border:none;
  background:#1f6feb;color:#fff;font-size:14px;font-weight:700;
  cursor:pointer;transition:all .15s;letter-spacing:0.3px;
  touch-action:manipulation;-webkit-tap-highlight-color:transparent;
}
#modal-overlay{touch-action:auto}
#modal{touch-action:auto}
#modal-continue:hover{background:#388bfd;transform:translateY(-1px);box-shadow:0 4px 12px rgba(31,111,235,0.4)}

/* === MEASURE TOOL === */
#measure-line{pointer-events:auto}
#measure-label{
  font-size:14px;font-weight:800;fill:#00d4ff;text-anchor:middle;
  paint-order:stroke;stroke:#000;stroke-width:3px;dominant-baseline:central;pointer-events:none;
}
#measure-info{
  position:absolute;top:54px;left:50%;transform:translateX(-50%);z-index:7;
  background:#161b22;border:1px solid #30363d;border-radius:8px;padding:6px 14px;
  font-size:11px;color:#c9d1d9;display:none;white-space:nowrap;
  box-shadow:0 4px 12px rgba(0,0,0,0.4);
}
#measure-info.show{display:block}

/* === LEGEND PANEL === */
#legend-panel{
  position:absolute;bottom:8px;left:8px;z-index:8;
  background:#161b22;border:1px solid #30363d;border-radius:8px;
  width:200px;overflow:hidden;display:none;
  box-shadow:0 4px 16px rgba(0,0,0,0.4);transition:all .2s;
}
#legend-panel.show{display:block}
#legend-panel.minimized .legend-body{display:none}
#legend-panel.minimized{width:auto}
#legend-panel::-webkit-scrollbar{width:4px}
#legend-panel::-webkit-scrollbar-thumb{background:#30363d;border-radius:3px}
.legend-hdr{padding:6px 10px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;user-select:none}
.legend-hdr h3{font-size:11px;font-weight:700;color:#58a6ff}
.legend-hdr button{width:20px;height:20px;border:none;background:transparent;color:#8b949e;cursor:pointer;font-size:13px;border-radius:4px;line-height:1}
.legend-hdr button:hover{background:#21262d;color:#58a6ff}
.legend-body{padding:4px 10px 8px}
.legend-item{display:flex;align-items:center;gap:8px;padding:4px 0;font-size:11px;color:#c9d1d9}
.legend-swatch{width:14px;height:14px;border-radius:3px;flex-shrink:0}


/* === MINIMAP === */
#minimap{
  position:absolute;top:8px;left:8px;z-index:6;
  width:160px;height:216px;background:#0d1117;border:1px solid #30363d;border-radius:8px;
  overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,0.5);cursor:pointer;
  transition:opacity .2s, transform .2s;opacity:0.85;
}
#minimap:hover{opacity:1;transform:scale(1.02)}
#minimap canvas{width:100%;height:100%;display:block}
#minimap .viewport-rect{
  position:absolute;border:2px solid #58a6ff;background:rgba(88,166,255,0.12);
  pointer-events:none;border-radius:1px;transition:all .05s;
  box-shadow:0 0 6px rgba(88,166,255,0.4);
}
#minimap-toggle{
  position:absolute;top:3px;right:3px;width:16px;height:16px;border-radius:3px;
  border:none;background:rgba(0,0,0,0.5);color:#8b949e;font-size:9px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;z-index:1;
}
#minimap-toggle:hover{background:rgba(255,255,255,0.15);color:#fff}
#minimap.collapsed{width:32px;height:32px;border-radius:6px}
#minimap.collapsed canvas{display:none}
#minimap.collapsed .viewport-rect{display:none}
#minimap.collapsed #minimap-toggle{top:50%;left:50%;transform:translate(-50%,-50%)}

/* === COORDINATE DISPLAY === */
#coord-display{
  position:absolute;bottom:10px;left:50%;transform:translateX(-50%);z-index:5;
  background:#161b22;border:1px solid #30363d;border-radius:6px;
  padding:3px 10px;font-size:10px;color:#8b949e;display:none;
  font-family:'SF Mono',Consolas,monospace;white-space:nowrap;
  box-shadow:0 2px 8px rgba(0,0,0,0.3);
}
#coord-display.show{display:flex;gap:8px;align-items:center}
.coord-input{
  width:48px;background:transparent;border:1px solid transparent;border-radius:3px;
  color:#58a6ff;font-weight:600;font-size:10px;font-family:inherit;
  text-align:center;padding:1px 2px;outline:none;
}
.coord-input:hover{border-color:#30363d}
.coord-input:focus{border-color:#58a6ff;background:#0d1117}
#coord-display .sep{color:#30363d}
#share-view-btn{
  background:transparent;border:none;color:#8b949e;cursor:pointer;font-size:12px;
  padding:0 2px;transition:color .1s;
}
#share-view-btn:hover{color:#58a6ff}

/* === SEARCH HIGHLIGHT GLOW === */
.lot-dot.search-glow{
  display:block!important;
  fill:rgba(88,166,255,0.3);stroke:#58a6ff;stroke-width:4;
  animation:searchPulse 1.2s ease-in-out infinite;
}
@keyframes searchPulse{
  0%,100%{r:26;opacity:0.6}
  50%{r:34;opacity:0.3}
}
.lot-label.search-glow{opacity:0.9!important;fill:#58a6ff;font-size:13px}



/* === INLINE TEXT EDITOR === */
.inline-text-editor{box-shadow:0 2px 12px rgba(88,166,255,0.3)}
.inline-text-editor:focus{border-color:#58a6ff}

/* === SMOOTH ZOOM === */
#wrap.animating{transition:transform .25s cubic-bezier(0.25,0.1,0.25,1)}

/* === PRINT STYLES === */
@media print{
  body{background:#fff!important;overflow:visible!important}
  #app{display:block!important;height:auto!important}
  .panel,#toolbar,#ctrls,#info,#toast,#anno-count,#eraser-cursor,#modal-overlay,#legend-panel,#measure-info{display:none!important}
  #map{position:static!important;overflow:visible!important;background:#fff!important;width:100%!important;height:auto!important}
  #wrap{position:static!important;transform:none!important}
  #img{width:100%!important;height:auto!important}
  #svg,#draw-svg{width:100%!important;height:auto!important;position:absolute!important;top:0;left:0}
}

@media(max-width:760px){
  #modal-overlay{padding:10px;align-items:flex-start}
  #modal{max-height:calc(100vh - 20px);max-height:calc(100dvh - 20px);margin:auto 0}
  .modal-top{padding:14px 16px 10px}
  .modal-top .logo{font-size:16px}
  .modal-body{padding:12px 16px;font-size:11px}
  .modal-body h3{font-size:12px;margin:10px 0 4px}
  .modal-body p{font-size:11px;line-height:1.5;margin-bottom:6px}
  .modal-body .note{font-size:10px;padding:6px 10px}
  .modal-footer{padding:10px 16px 14px}
  .modal-footer p{font-size:9px!important}
  #modal-continue{padding:8px 30px;font-size:13px}
}
</style>
</head>
<body>

<!-- WELCOME MODAL -->
<div id="modal-overlay">
<div id="modal">
  <div class="modal-top">
    <div class="logo">Twin Lakes Road Maintenance Association</div>
    <div class="org-tag">Interactive Map ‚Äî Created by the Board</div>
  </div>
  <div class="modal-body">
    <h3>üìç What is this?</h3>
    <p>The Twin Lakes RMA board built this tool to help our community explore and reference the recorded survey of our subdivision. The background image is a direct copy of the survey on file ‚Äî it spans two pages, so you'll see both as you scroll up and down.</p>

    <h3>üè† Lots (Left Panel)</h3>
    <p>All 59 lots are listed on the left. Click any lot to highlight its location on the map. Some lots appear on both survey pages ‚Äî you'll see a <strong style="color:#d29922">1&amp;2</strong> badge when that's the case, and the lot will be marked in both places.</p>

    <h3>üõ§Ô∏è Road Points (Right Panel)</h3>
    <p>On the right, you'll find reference points along each road, organized by letter: <strong style="color:#ef4444">A ‚Äî Lakeside Lane</strong>, <strong style="color:#f97316">B ‚Äî Creekside Court</strong>, <strong style="color:#eab308">C ‚Äî Twin Lakes Trail</strong>, and <strong style="color:#22c55e">D ‚Äî Westlake Court</strong>. Click any point (e.g., A1, A2) to jump to that location. Points that appear on both pages will show on both.</p>

    <h3>‚úèÔ∏è Markup Tools (Top Toolbar)</h3>
    <p>Use the toolbar above the map to draw, highlight, add text, or drop mark points (P1, P2, P3‚Ä¶). There's also an eraser, undo, and a screenshot tool that lets you select an area and save it as an image.</p>
    <p><strong style="color:#c9d1d9">Tip:</strong> To move a markup you've placed, click the <strong style="color:#c9d1d9">‚ú•</strong> (four-arrow) button next to the eraser, then drag any annotation to reposition it.</p>

    <div class="note">‚ö†Ô∏è <strong>Accuracy Note:</strong> The survey image is the recorded document. All lot markers, road points, and tools were placed by the RMA board and may not be 100% precise. If you spot an error, please let the board know so we can correct it.</div>
  </div>
  <div class="modal-footer">
    <p style="font-size:10px;color:#8b949e;text-align:center;margin-bottom:10px;width:100%">To see these instructions again, click the <strong style="color:#c9d1d9">‚ìò</strong> button on the top toolbar.</p>
    <button id="modal-continue">Continue to Map</button>
  </div>
</div>
</div>

<div id="app">

<!-- MOBILE TAB BAR -->
<div id="mobile-tabs">
  <button class="mtab active" data-panel="left-panel">Lots</button>
  <button class="mtab" data-panel="right-panel">Road Points</button>
</div>

<!-- LEFT PANEL: LOTS -->
<div class="panel panel-l" id="left-panel">
  <div id="title-bar">
    <h1>THE RANCHES AT TWIN LAKES</h1>
    <div class="subtitle">Final Plat &bull; Lamar County, Texas &bull; 59 Lots &bull; ~591 Acres</div>
    <div class="org">Twin Lakes RMA</div>
  </div>
  <div class="panel-hdr" id="lot-hdr"><h2 style="color:#58a6ff">Lots</h2><div class="sub">Click a lot to highlight on map</div></div>
  <div class="search-wrap"><input type="text" id="lot-search" placeholder="Search lot # or owner..." autocomplete="off"></div>
  <div class="item-list" id="lot-list"></div>
  <div class="panel-stats"><span>59 Lots</span></div>
</div>

<!-- MAP -->
<div id="map">
  <div id="wrap">
    <img id="img" src="plat_combined_web.jpg" alt="Twin Lakes Plat ‚Äî Sheet 1 & Sheet 2">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
    <svg id="draw-svg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <div id="toolbar">
    <button class="tb on" data-tool="pan" title="Pan (V)">‚úã<span class="tb-tip">Pan</span></button>
    <div class="tb-sep"></div>
    <button class="tb" data-tool="pen" title="Pen (P)"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg><span class="tb-tip">Pen</span></button>
    <button class="tb" data-tool="hl" title="Highlighter (H)"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4"/></svg><span class="tb-tip">Highlight</span></button>
    <button class="tb" data-tool="text" title="Text (T)">T<span class="tb-tip">Text</span></button>
    <button class="tb" data-tool="dot" title="Mark Point (D)">‚óè<span class="tb-tip">Mark</span></button>
    <div class="tb-sep"></div>
    <div class="tb" title="Drawing Color">
      <span class="color-preview" id="color-prev" style="background:#ff4444"></span>
      <input type="color" id="draw-color" value="#ff4444">
      <span class="tb-tip">Color</span>
    </div>
    <label class="tb-label">Size</label>
    <input type="number" id="stroke-size" value="6" min="1" max="40">
    <div class="tb-sep"></div>
    <button class="tb" data-tool="move" title="Move annotation (M)">‚ú•<span class="tb-tip">Move</span></button>
    <button class="tb" data-tool="eraser" title="Eraser (E)"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 21h10"/><path d="m5.5 12.5 5-5a2.12 2.12 0 0 1 3 0l3 3a2.12 2.12 0 0 1 0 3l-5 5H7l-3-3a2 2 0 0 1 0-2.83Z"/></svg><span class="tb-tip">Erase</span></button>
    <button class="tb" id="undo-btn" title="Undo (Ctrl+Z)">‚Ü©<span class="tb-tip">Undo</span></button>
    <button class="tb" id="clear-btn" title="Clear All">üóë<span class="tb-tip">Clear All</span></button>
    <div class="tb-sep"></div>
    <button class="tb" data-tool="measure" title="Measure distance (R)">üìè<span class="tb-tip">Ruler</span></button>
    <div class="tb-sep"></div>
    <button class="tb" data-tool="screenshot" title="Screenshot area (S)"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><path d="M3 7V3h4"/><path d="M17 3h4v4"/><path d="M21 17v4h-4"/><path d="M7 21H3v-4"/></svg><span class="tb-tip">Screenshot</span></button>
    <div class="tb-sep"></div>
    <button class="tb" id="legend-btn" title="Toggle Legend">üó∫Ô∏è<span class="tb-tip">Legend</span></button>
    <button class="tb" id="info-btn" title="Help & Info (I)"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg><span class="tb-tip">Help</span></button>
  </div>

  <div id="ctrls">
    <button class="cb" id="zi" title="Zoom In (+)">+</button>
    <button class="cb" id="zo" title="Zoom Out (-)">‚àí</button>
    <button class="cb" id="zr" title="Fit (0)">‚ü≤</button>
    <button class="cb" id="zc" title="Center on Selection (C)" style="font-size:12px;margin-top:2px;border-top:1px solid #30363d">‚äô</button>
  </div>

  <div id="info">
    <div id="info-head"><span id="info-t">‚Äî</span><button id="info-x">‚úï</button></div>
    <div id="info-b"></div>
  </div>
  <div id="toast"></div>
  <div id="anno-count"></div>
  <div id="sel-rect"></div>
  <div id="eraser-cursor"></div>
  <div id="measure-info"></div>
  <div id="coord-display"><span>X: <input class="coord-input" id="coord-x" value="‚Äî" title="X % ‚Äî edit to navigate"></span><span class="sep">|</span><span>Y: <input class="coord-input" id="coord-y" value="‚Äî" title="Y % ‚Äî edit to navigate"></span><span class="sep">|</span><span>Zoom: <input class="coord-input" id="coord-z" value="‚Äî" title="Zoom % ‚Äî edit to set zoom"></span><span class="sep">|</span><button id="share-view-btn" title="Copy shareable link">üîó</button></div>
  <div id="minimap"><button id="minimap-toggle">‚ó≥</button><canvas id="minimap-canvas"></canvas><div class="viewport-rect" id="minimap-vp"></div></div>
  <div id="legend-panel" class="show">
    <div class="legend-hdr"><h3>Legend</h3><button id="legend-minimize" title="Minimize legend">‚ñæ</button></div>
    <div class="legend-body">
      <div class="legend-item"><span class="legend-swatch" style="background:#ef4444"></span>A ‚Äî Lakeside Lane</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#f97316"></span>B ‚Äî Creekside Court</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#eab308"></span>C ‚Äî Twin Lakes Trail</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#22c55e"></span>D ‚Äî Westlake Court</div>
    </div>
  </div>
</div>

<!-- RIGHT PANEL: ROAD POINTS -->
<div class="panel panel-r" id="right-panel">
  <div class="panel-hdr" id="pt-hdr"><h2 style="color:#f97316">Road Points</h2><div class="sub">Click a point to highlight on map</div></div>
  <div class="search-wrap"><input type="text" id="pt-search" placeholder="Search road or point (e.g. Lakeside, A, C3)..." autocomplete="off"></div>
  <div class="filter-area" id="filter-area">
    <h3>Filter by Road</h3>
    <div class="chips" id="chips"></div>
  </div>
  <div class="item-list" id="pt-list"></div>
  <div class="panel-stats" id="pt-stats"><span>25 Points</span><span>4 Roads</span></div>
</div>

</div>

<script>
const IW = 4000, IH = 5397;

// ===== LOT DATA =====
const D = {};
for (let i = 1; i <= 59; i++) D[i] = { a: 10.01 };
// Owner data
const OWNERS = {
  1: 'Developer owned',
  6: 'Erik Adelson',
  11: 'Developer owned',
  15: 'Developer owned',
  18: 'Ranju Mathew',
  19: 'Abe Varughese',
  22: 'Developer owned',
  28: 'Abe Varughese',
  29: 'Abe Varughese',
  31: 'Abe Varughese',
  54: 'Developer owned',
};

// ===== LOT POSITIONS =====
const P = {
  1:[[72.59,64.46]], 2:[[67.91,61.78],[69.09,45.71]], 3:[[64.66,56.36],[66.59,42.88]],
  4:[[62.22,52.7],[63.53,39.09]], 5:[[51.42,51.68],[60.57,35.47]], 6:[[62.45,34.08]],
  7:[[65.23,34.88],[67.67,54.76]], 8:[[71.71,31.26],[70.4,52.15]], 9:[[69.52,22.96]],
  10:[[68.91,18.02]], 11:[[67.31,13.36]], 12:[[63.51,10.62]], 13:[[50.01,11.69]],
  14:[[44.82,13.28]], 15:[[50.06,18.63]], 16:[[50.12,20.35]], 17:[[51.49,24.02]],
  18:[[48.63,25.09]], 19:[[46.24,23.29]], 20:[[45.06,20.28]], 21:[[42.83,17.31]],
  22:[[39.77,14.68]], 23:[[36.59,11.37]], 24:[[30.1,9.43]], 25:[[24.76,18.9]],
  26:[[26.77,27.49]], 27:[[29.18,33.39]], 28:[[32.92,35.41],[28.38,51.43]],
  29:[[36.39,37.59],[32.12,51.97]], 30:[[38.66,39.81],[36.66,53.31]],
  31:[[41.72,42.33],[39.99,55.73]], 32:[[45.13,44.51],[42.99,58]],
  33:[[50.6,45.89],[48.93,59.29]], 34:[[55.06,47.47],[50.13,63.24]],
  35:[[54.13,65.91]], 36:[[56.22,69.3]], 37:[[53.74,71.55]], 38:[[48.89,73.31]],
  39:[[42.22,72]], 40:[[40.68,69.43]], 41:[[33.68,69.43]], 42:[[32.24,76]],
  43:[[32.19,81.85]], 44:[[31.03,86.67]], 45:[[24.2,85.85]], 46:[[22.76,84.26]],
  47:[[22.38,82.17]], 48:[[11.52,83.93]], 49:[[16.86,79.23]], 50:[[22.38,75.64]],
  51:[[22.49,70.05]], 52:[[27.11,66.69]], 53:[[27.36,65.56]],
  54:[[29.75,61.62],[33.19,47.91]], 55:[[29.7,58.74],[31.5,45.51]],
  56:[[26.63,55.26],[28.23,42.03]], 57:[[24.84,52.32],[26.54,39.1]],
  58:[[25.57,36.35],[10.88,51.9]], 59:[[23.31,32.34]],
};

// ===== ROAD POINTS =====
const ROAD_POINTS = {
  A: {
    color: '#ef4444', name: 'Lakeside Lane',
    points: [
      { num:1, dots:[[37.72,9.89]] },
      { num:2, dots:[[39.39,12.37]] },
      { num:3, dots:[[45.97,16.07]] },
      { num:4, dots:[[47.23,18.79]] },
      { num:5, dots:[[47.95,21.34]] },
      { num:6, dots:[[48.29,22.51]] },
    ]
  },
  B: {
    color: '#f97316', name: 'Creekside Court',
    points: [
      { num:1, dots:[[63.23,35.59]] },
      { num:2, dots:[[66.49,40.39],[64.71,53.79]] },
      { num:3, dots:[[70.14,58.44],[71.84,44.99]] },
      { num:4, dots:[[71.87,58.9],[73.57,45.46]] },
    ]
  },
  C: {
    color: '#eab308', name: 'Twin Lakes Trail',
    points: [
      { num:1, dots:[[21.03,27.77]] },
      { num:2, dots:[[23.72,29.33]] },
      { num:3, dots:[[27,35.05]] },
      { num:4, dots:[[28.21,39.31],[26.56,52.65]] },
      { num:5, dots:[[31.45,57.4],[33.1,44.03]] },
      { num:6, dots:[[37.7,47.29],[36.08,60.64]] },
      { num:7, dots:[[41.35,64.45]] },
      { num:8, dots:[[46.13,68.19]] },
      { num:9, dots:[[48.9,70.4]] },
    ]
  },
  D: {
    color: '#22c55e', name: 'Westlake Court',
    points: [
      { num:1, dots:[[34.12,60.07]] },
      { num:2, dots:[[32.24,63.86]] },
      { num:3, dots:[[28.93,71.9]] },
      { num:4, dots:[[24.96,76.41]] },
      { num:5, dots:[[25.61,80.86]] },
      { num:6, dots:[[25.96,82.58]] },
    ]
  },
};

// ===== SVG SETUP =====
const svg = document.getElementById('svg');
svg.setAttribute('viewBox', `0 0 ${IW} ${IH}`);
svg.setAttribute('preserveAspectRatio', 'none');
const drawSvg = document.getElementById('draw-svg');
drawSvg.setAttribute('viewBox', `0 0 ${IW} ${IH}`);
drawSvg.setAttribute('preserveAspectRatio', 'none');

// Eraser mask: white rect = visible, black strokes = erased
const eraseDefs = document.createElementNS('http://www.w3.org/2000/svg','defs');
const eraseMask = document.createElementNS('http://www.w3.org/2000/svg','mask');
eraseMask.id = 'erase-mask';
eraseMask.setAttribute('maskUnits','userSpaceOnUse');
eraseMask.setAttribute('x','0'); eraseMask.setAttribute('y','0');
eraseMask.setAttribute('width',IW); eraseMask.setAttribute('height',IH);
const maskRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
maskRect.setAttribute('width',IW); maskRect.setAttribute('height',IH);
maskRect.setAttribute('fill','white');
eraseMask.appendChild(maskRect);
eraseDefs.appendChild(eraseMask);
drawSvg.appendChild(eraseDefs);

// Masked group for pen/highlighter strokes (eraser affects only this group)
const drawStrokes = document.createElementNS('http://www.w3.org/2000/svg','g');
drawStrokes.id = 'draw-strokes';
drawStrokes.setAttribute('mask','url(#erase-mask)');
drawSvg.appendChild(drawStrokes);

// ===== LOT SVG ELEMENTS =====
const lotDots = {}, lotLabels = {};
for (const n in P) {
  lotDots[n] = []; lotLabels[n] = [];
  P[n].forEach(([cxp, cyp], i) => {
    const cx = cxp/100*IW, cy = cyp/100*IH;
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 22);
    c.classList.add('lot-dot');
    if (i > 0) c.style.stroke = '#c084fc';
    c.style.display = 'none';
    svg.appendChild(c);
    lotDots[n].push(c);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', cx); t.setAttribute('y', cy);
    t.classList.add('lot-label'); t.textContent = n;
    svg.appendChild(t);
    lotLabels[n].push(t);
  });
}

// ===== ROAD POINT SVG ELEMENTS =====
const rpEls = {};
for (const g in ROAD_POINTS) {
  rpEls[g] = [];
  const grp = ROAD_POINTS[g];
  grp.points.forEach((pt) => {
    const els = { dots:[], labels:[] };
    pt.dots.forEach(([cxp, cyp], di) => {
      const cx = cxp/100*IW, cy = cyp/100*IH;
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 10);
      c.setAttribute('fill', grp.color);
      c.classList.add('rp-dot');
      if (di > 0) c.setAttribute('stroke-dasharray','3,2');
      svg.appendChild(c);
      els.dots.push(c);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', cx); t.setAttribute('y', cy - 16);
      t.classList.add('rp-label');
      t.textContent = g + pt.num;
      svg.appendChild(t);
      els.labels.push(t);
    });
    rpEls[g].push(els);
  });
}

// ===== STATE =====
let curFilter = null, curLot = null, curPoint = null;
let curLotSheetIdx = 0, curPointSheetIdx = 0; // track which sheet position we're viewing
let activeTool = 'pan';

// ===== MOBILE: TABBED PANELS =====
let mobileActivePanel = null; // 'left-panel' or 'right-panel' or null (collapsed)
function setupMobile() {
  if (window.innerWidth > 760) return;
  const lp = document.getElementById('left-panel');
  const rp = document.getElementById('right-panel');
  lp.classList.remove('mobile-active');
  rp.classList.remove('mobile-active');
  mobileActivePanel = null;
}
// Tab click handler
document.querySelectorAll('#mobile-tabs .mtab').forEach(tab => {
  tab.addEventListener('click', () => {
    if (window.innerWidth > 760) return;
    const panelId = tab.dataset.panel;
    const lp = document.getElementById('left-panel');
    const rp = document.getElementById('right-panel');
    const tabs = document.querySelectorAll('#mobile-tabs .mtab');

    if (mobileActivePanel === panelId) {
      // Tapping active tab collapses it
      lp.classList.remove('mobile-active');
      rp.classList.remove('mobile-active');
      tabs.forEach(t => t.classList.remove('active'));
      mobileActivePanel = null;
      return;
    }

    // Switch to tapped tab
    lp.classList.remove('mobile-active');
    rp.classList.remove('mobile-active');
    tabs.forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(panelId).classList.add('mobile-active');
    mobileActivePanel = panelId;
  });
});

// Also keep old header clicks working (for desktop)
document.getElementById('lot-hdr').onclick = () => {
  if (window.innerWidth > 760) return;
  // On mobile, simulate tab click for Lots
  document.querySelector('#mobile-tabs .mtab[data-panel="left-panel"]').click();
};
document.getElementById('pt-hdr').onclick = () => {
  if (window.innerWidth > 760) return;
  document.querySelector('#mobile-tabs .mtab[data-panel="right-panel"]').click();
};

setupMobile();
window.addEventListener('resize', () => {
  if (window.innerWidth > 760) {
    document.getElementById('left-panel').classList.remove('mobile-active');
    document.getElementById('right-panel').classList.remove('mobile-active');
    mobileActivePanel = null;
  } else {
    setupMobile();
  }
});

// ===== BUILD LOT LIST =====
const lotList = document.getElementById('lot-list');
function buildLotList(q) {
  lotList.innerHTML = '';
  const s = (q||'').toLowerCase();
  Object.keys(D).map(Number).sort((a,b)=>a-b).forEach(n => {
    if (s && !String(n).includes(s) && !(OWNERS[n]||'').toLowerCase().includes(s)) return;
    const div = mk('div','li');
    div.dataset.lot = n;
    const owner = OWNERS[n] || '';
    let html = `<span class="num">Lot ${n}</span>`;
    if (owner) html += `<span class="owner">${owner}</span>`;
    /* acreage removed */
    if (P[n] && P[n].length > 1) html += `<span class="sheet-badge">1&2</span>`;
    div.innerHTML = html;
    div.onclick = () => selLot(n);
    lotList.appendChild(div);
  });
}

// ===== BUILD ROAD POINT LIST =====
const ptList = document.getElementById('pt-list');
function buildPtList(q) {
  ptList.innerHTML = '';
  const s = (q||'').trim().toLowerCase();
  // Determine which groups match the search (by letter or road name)
  let matchedGroups = null;
  if (s) {
    matchedGroups = [];
    for (const g in ROAD_POINTS) {
      const grp = ROAD_POINTS[g];
      const roadName = (grp.name || '').toLowerCase();
      const letter = g.toLowerCase();
      if (letter === s || roadName.includes(s) || (letter + ' ‚Äî ' + roadName).includes(s)) {
        matchedGroups.push(g);
      }
    }
  }
  const groups = curFilter ? [curFilter] : Object.keys(ROAD_POINTS).sort();
  // If search matched specific roads, narrow to those (intersect with curFilter if set)
  const showGroups = matchedGroups && matchedGroups.length > 0
    ? groups.filter(g => matchedGroups.includes(g))
    : groups;
  let totalShown = 0;
  showGroups.forEach(g => {
    const grp = ROAD_POINTS[g];
    const color = grp.color;
    // If search matched a road, show all its points; otherwise filter individual points
    const roadMatched = matchedGroups && matchedGroups.includes(g);
    const visiblePts = [];
    grp.points.forEach((pt, idx) => {
      const label = g + pt.num;
      if (s && !roadMatched && !label.toLowerCase().includes(s) && !(pt.desc||'').toLowerCase().includes(s)) return;
      visiblePts.push({ pt, idx });
    });
    if (visiblePts.length === 0) return;
    const hdr = mk('div','grp-hdr');
    const rname = grp.name ? ` ‚Äî ${grp.name}` : '';
    hdr.innerHTML = `<span class="grp-dot" style="background:${color}"></span><span style="color:${color}">${g}${rname}</span><span style="color:#8b949e;font-weight:400">${visiblePts.length} pts</span>`;
    ptList.appendChild(hdr);
    visiblePts.forEach(({ pt, idx }) => {
      const label = g + pt.num;
      const div = mk('div','pi');
      div.style.borderLeftColor = color;
      div.dataset.group = g; div.dataset.idx = idx;
      let html = `<span class="plabel" style="color:${color}">${label}</span>`;
      html += `<span class="pdesc">${pt.desc||'‚Äî'}</span>`;
      if (pt.dots.length > 1) html += `<span class="sheet-badge">1&2</span>`;
      div.innerHTML = html;
      div.onclick = () => selPoint(g, idx);
      ptList.appendChild(div);
      totalShown++;
    });
  });
  // Also update map visibility to dim non-matching road points when searching
  if (s && matchedGroups && matchedGroups.length > 0) {
    for (const g in rpEls) {
      rpEls[g].forEach(els => {
        const dim = !matchedGroups.includes(g);
        els.dots.forEach(c => { c.classList.toggle('dim', dim); c.classList.remove('hi'); });
        els.labels.forEach(t => { t.classList.toggle('dim', dim); t.classList.remove('hi'); });
      });
    }
  } else if (!s) {
    updateRPVisibility();
  }
}

// ===== FILTER CHIPS =====
function buildChips() {
  const wrap = document.getElementById('chips');
  wrap.innerHTML = '';
  const allC = mk('span','chip' + (!curFilter ? ' on' : ''));
  allC.textContent = 'All';
  allC.style.borderColor = '#58a6ff';
  if (!curFilter) allC.style.background = '#1f6feb';
  allC.onclick = () => { curFilter = null; buildChips(); buildPtList(); updatePtStats(); updateRPVisibility(); };
  wrap.appendChild(allC);
  for (const g in ROAD_POINTS) {
    const color = ROAD_POINTS[g].color;
    const c = mk('span','chip' + (curFilter===g ? ' on' : ''));
    const rname = ROAD_POINTS[g].name ? g + ' ‚Äî ' + ROAD_POINTS[g].name : g;
    c.textContent = rname + ' (' + ROAD_POINTS[g].points.length + ')';
    c.style.borderColor = color;
    if (curFilter===g) c.style.background = color;
    c.onclick = () => {
      curFilter = curFilter===g ? null : g;
      buildChips(); buildPtList(); updatePtStats(); updateRPVisibility();
      if (curFilter) toast((ROAD_POINTS[g].name||'Group '+g) + ' ¬∑ ' + ROAD_POINTS[g].points.length + ' pts');
    };
    wrap.appendChild(c);
  }
}

function updatePtStats() {
  let total = 0;
  (curFilter ? [curFilter] : Object.keys(ROAD_POINTS)).forEach(g => { total += ROAD_POINTS[g].points.length; });
  document.getElementById('pt-stats').innerHTML =
    `<span>${total} Point${total!==1?'s':''}</span><span>${Object.keys(ROAD_POINTS).length} Roads</span>`;
}

function updateRPVisibility() {
  for (const g in rpEls) {
    rpEls[g].forEach(els => {
      const dim = curFilter && curFilter !== g;
      els.dots.forEach(c => { c.classList.toggle('dim', dim); c.classList.remove('hi'); });
      els.labels.forEach(t => { t.classList.toggle('dim', dim); t.classList.remove('hi'); });
    });
  }
}

// Helper: collapse mobile panel after selection so map is visible
function collapseMobilePanel() {
  if (window.innerWidth > 760) return;
  document.getElementById('left-panel').classList.remove('mobile-active');
  document.getElementById('right-panel').classList.remove('mobile-active');
  // Keep tab highlighted but panel hidden
  mobileActivePanel = null;
}

// ===== SELECT LOT =====
function selLot(n) {
  // If already selected: cycle between sheet positions if multiple, otherwise deselect
  if (curLot === n) {
    if (P[n] && P[n].length > 1) {
      curLotSheetIdx = (curLotSheetIdx + 1) % P[n].length;
      zoomToCoord(P[n][curLotSheetIdx]);
      toast('Lot ' + n + ' ¬∑ Sheet ' + (curLotSheetIdx + 1));
      return;
    }
    closeInfo(); return;
  }
  clearSelection(); curLot = n; curLotSheetIdx = 0;
  if (lotDots[n]) lotDots[n].forEach(c => { c.style.display=''; c.classList.add('show'); });
  if (lotLabels[n]) lotLabels[n].forEach(t => t.classList.add('show'));
  const li = lotList.querySelector(`[data-lot="${n}"]`);
  if (li) { li.classList.add('act'); li.scrollIntoView({behavior:'smooth',block:'nearest'}); }
  document.getElementById('info-t').textContent = 'Lot ' + n;
  let h = '';
  if (OWNERS[n]) h += `<div class="ic"><div class="ic-l">Owner</div><div class="ic-v blu">${OWNERS[n]}</div></div>`;
  if (P[n] && P[n].length > 1) h += `<div class="ic"><div class="ic-l">Sheets</div><div class="ic-v ylw">Shown on both Sheet 1 &amp; 2 ¬∑ Click again to switch</div></div>`;
  document.getElementById('info-b').innerHTML = h;
  document.getElementById('info').classList.add('show');
  zoomToCoord(P[n][0]);
  collapseMobilePanel();
}

// ===== SELECT ROAD POINT =====
function selPoint(g, idx) {
  // If already selected: cycle between sheet positions if multiple, otherwise deselect
  if (curPoint && curPoint.g === g && curPoint.idx === idx) {
    const pt = ROAD_POINTS[g].points[idx];
    if (pt.dots.length > 1) {
      curPointSheetIdx = (curPointSheetIdx + 1) % pt.dots.length;
      zoomToCoord(pt.dots[curPointSheetIdx]);
      toast(g + pt.num + ' ¬∑ Sheet ' + (curPointSheetIdx + 1));
      return;
    }
    closeInfo(); return;
  }
  clearSelection(); curPoint = { g, idx }; curPointSheetIdx = 0;
  const grp = ROAD_POINTS[g], pt = grp.points[idx], color = grp.color;
  rpEls[g][idx].dots.forEach(c => c.classList.add('hi'));
  rpEls[g][idx].labels.forEach(t => t.classList.add('hi'));
  const item = ptList.querySelector(`[data-group="${g}"][data-idx="${idx}"]`);
  if (item) { item.classList.add('act'); item.scrollIntoView({behavior:'smooth',block:'nearest'}); }
  const rname = grp.name ? ` ‚Äî ${grp.name}` : '';
  document.getElementById('info-t').innerHTML = `<span style="color:${color}">‚óè</span> Point ${g}${pt.num}`;
  let h = `<div class="ic"><div class="ic-l">Road</div><div class="ic-v" style="color:${color}">${g}${rname}</div></div>`;
  if (pt.dots.length > 1) h += `<div class="ic"><div class="ic-l">Sheets</div><div class="ic-v ylw">Shown on both Sheet 1 &amp; 2 ¬∑ Click again to switch</div></div>`;
  if (pt.desc) h += `<div class="in"><h4>Description</h4><p>${pt.desc}</p></div>`;
  document.getElementById('info-b').innerHTML = h;
  document.getElementById('info').classList.add('show');
  zoomToCoord(pt.dots[0]);
  collapseMobilePanel();
}

// ===== CLEAR / CLOSE =====
function clearSelection() {
  if (curLot) {
    if (lotDots[curLot]) lotDots[curLot].forEach(c => { c.style.display='none'; c.classList.remove('show'); });
    if (lotLabels[curLot]) lotLabels[curLot].forEach(t => t.classList.remove('show'));
    curLot = null;
  }
  if (curPoint) {
    const {g, idx} = curPoint;
    if (rpEls[g]?.[idx]) {
      rpEls[g][idx].dots.forEach(c => c.classList.remove('hi'));
      rpEls[g][idx].labels.forEach(t => t.classList.remove('hi'));
    }
    curPoint = null;
  }
  document.querySelectorAll('.li.act,.pi.act').forEach(e => e.classList.remove('act'));
}
function closeInfo() { document.getElementById('info').classList.remove('show'); clearSelection(); }
document.getElementById('info-x').onclick = closeInfo;

function panToCoord(coords) {
  if (!coords) return;
  const [cxp, cyp] = coords;
  const cx = cxp/100*IW, cy = cyp/100*IH;
  const r = mc.getBoundingClientRect();
  const screenX = cx*scale+px, screenY = cy*scale+py;
  if (screenX<80||screenX>r.width-80||screenY<80||screenY>r.height-200) {
    px = r.width/2 - cx*scale; py = r.height/2 - cy*scale; upd();
  }
}

// Smart zoom: centers on coords and zooms in. Mobile zooms more aggressively.
function zoomToCoord(coords) {
  if (!coords) return;
  const [cxp, cyp] = coords;
  const cx = cxp/100*IW, cy = cyp/100*IH;
  const r = mc.getBoundingClientRect();
  const isMobile = window.innerWidth <= 760;
  // Gentle zoom: show the lot/point with plenty of surrounding context
  // Desktop: ~0.65x (see a large section of the plat). Mobile: ~1.1x (slightly closer).
  const targetScale = isMobile ? 1.1 : 0.65;
  // Always set to target scale and center ‚Äî gives a consistent, comfortable view
  scale = targetScale;
  px = r.width/2 - cx*scale;
  py = r.height/2 - cy*scale;
  upd();
}

// Center View button: zoom+center on current selection (at current sheet index), or fit all
function centerView() {
  if (curLot && P[curLot]) {
    const idx = Math.min(curLotSheetIdx, P[curLot].length - 1);
    zoomToCoord(P[curLot][idx]);
    toast('Centered on Lot ' + curLot + (P[curLot].length > 1 ? ' ¬∑ Sheet ' + (idx + 1) : ''));
  } else if (curPoint) {
    const pt = ROAD_POINTS[curPoint.g].points[curPoint.idx];
    const idx = Math.min(curPointSheetIdx, pt.dots.length - 1);
    zoomToCoord(pt.dots[idx]);
    toast('Centered on ' + curPoint.g + pt.num + (pt.dots.length > 1 ? ' ¬∑ Sheet ' + (idx + 1) : ''));
  } else {
    fit();
    toast('View reset');
  }
}

// ===== SEARCH =====
document.getElementById('lot-search').addEventListener('input', e => buildLotList(e.target.value));
document.getElementById('pt-search').addEventListener('input', e => buildPtList(e.target.value));

// ===== PAN & ZOOM =====
const mc = document.getElementById('map'), mw = document.getElementById('wrap');
let scale=1, px=0, py=0, drag=false, sx, sy;

function upd() { mw.style.transform = `translate(${px}px,${py}px) scale(${scale})`; }
function fit() {
  const cw=mc.clientWidth, ch=mc.clientHeight;
  scale = Math.min(cw/IW, ch/IH)*0.96;
  px = (cw-IW*scale)/2; py = (ch-IH*scale)/2; upd();
}
const img = document.getElementById('img');
img.onload = fit; if (img.complete) fit();
// On resize, only re-fit if nothing is selected (avoids losing your place)
window.addEventListener('resize', () => { if (!curLot && !curPoint) fit(); });

function screenToSvg(clientX, clientY) {
  const r = mc.getBoundingClientRect();
  return [(clientX - r.left - px) / scale, (clientY - r.top - py) / scale];
}

// ===== DRAWING STATE =====
let drawColor = '#ff4444', drawSize = 6;
let drawing = false, curPath = null;
let drawHistory = [];
let dotCounter = 0;
let usedDotNumbers = new Set(); // Track which P-numbers are currently in use

function getNextDotNumber() {
  // Find the lowest available number starting from 1
  let n = 1;
  while (usedDotNumbers.has(n)) n++;
  usedDotNumbers.add(n);
  dotCounter = Math.max(dotCounter, n);
  return n;
}

function releaseDotNumber(label) {
  // Parse "P3" -> 3 and remove from used set
  const m = label.match(/^P(\d+)$/);
  if (m) usedDotNumbers.delete(parseInt(m[1]));
}
let selecting = false, selStart = null;

document.getElementById('draw-color').addEventListener('input', e => {
  drawColor = e.target.value;
  document.getElementById('color-prev').style.background = drawColor;
});
document.getElementById('stroke-size').addEventListener('input', e => {
  drawSize = Math.max(1, Math.min(40, parseInt(e.target.value)||4));
  updateEraserCursorSize();
});

function updateAnnoCount() {
  const el = document.getElementById('anno-count');
  if (drawHistory.length > 0) {
    el.textContent = drawHistory.length + ' annotation' + (drawHistory.length!==1?'s':'');
    el.classList.add('show');
  } else {
    el.classList.remove('show');
  }
}

// ===== ERASER CURSOR =====
const eraserCursor = document.getElementById('eraser-cursor');
function getEraserScreenRadius() {
  // Convert SVG-space eraser width to screen pixels
  return (drawSize * 8 * scale) / 2;
}
function updateEraserCursorSize() {
  if (activeTool !== 'eraser') return;
  const d = getEraserScreenRadius() * 2;
  eraserCursor.style.width = d + 'px';
  eraserCursor.style.height = d + 'px';
}
function moveEraserCursor(clientX, clientY) {
  if (activeTool !== 'eraser') return;
  const r = mc.getBoundingClientRect();
  eraserCursor.style.left = (clientX - r.left) + 'px';
  eraserCursor.style.top = (clientY - r.top) + 'px';
}
function showEraserCursor() { eraserCursor.style.display = 'block'; updateEraserCursorSize(); }
function hideEraserCursor() { eraserCursor.style.display = 'none'; }

function spawnEraserStamp(clientX, clientY) {
  const r = mc.getBoundingClientRect();
  const d = getEraserScreenRadius() * 2;
  const stamp = document.createElement('div');
  stamp.className = 'eraser-stamp';
  stamp.style.left = (clientX - r.left) + 'px';
  stamp.style.top = (clientY - r.top) + 'px';
  stamp.style.width = d + 'px';
  stamp.style.height = d + 'px';
  mc.appendChild(stamp);
  stamp.addEventListener('animationend', () => stamp.remove());
}

// Track mouse over map for eraser cursor
mc.addEventListener('mousemove', e => {
  if (activeTool === 'eraser') {
    moveEraserCursor(e.clientX, e.clientY);
  }
});
mc.addEventListener('mouseleave', () => { if (activeTool === 'eraser') hideEraserCursor(); });
mc.addEventListener('mouseenter', e => { if (activeTool === 'eraser') { showEraserCursor(); moveEraserCursor(e.clientX, e.clientY); } });

// ===== PER-TOOL DEFAULT SIZES =====
const TOOL_SIZES = { text: 2, dot: 4, pen: 6, hl: 8 };

// ===== TOOLBAR =====
function setTool(tool) {
  activeTool = tool;
  document.querySelectorAll('.tb[data-tool]').forEach(b => b.classList.remove('on'));
  const btn = document.querySelector(`[data-tool="${tool}"]`);
  if (btn) btn.classList.add('on');
  mc.className = (tool === 'pan') ? '' : 'tool-' + tool;
  // Set per-tool default size
  if (TOOL_SIZES[tool] !== undefined) {
    drawSize = TOOL_SIZES[tool];
    document.getElementById('stroke-size').value = drawSize;
  }
  // Toggle interactive modes on draw SVG
  drawSvg.classList.remove('interactive');
  drawSvg.style.pointerEvents = '';
  drawStrokes.style.pointerEvents = '';
  if (tool === 'move') drawSvg.classList.add('interactive');
  if (tool === 'eraser') { drawSvg.style.pointerEvents = 'all'; drawStrokes.style.pointerEvents = 'none'; }
  // Eraser cursor visibility
  if (tool === 'eraser') { showEraserCursor(); } else { hideEraserCursor(); }
  // Clear any lingering selection rect
  if (tool !== 'screenshot') { selecting = false; document.getElementById('sel-rect').style.display = 'none'; }
  // Ruler persists when switching away, but starting a new measurement clears the old one
  if (tool === 'measure' && typeof clearMeasure === 'function') clearMeasure();
}
document.querySelectorAll('.tb[data-tool]').forEach(btn => {
  btn.onclick = () => setTool(btn.dataset.tool);
});

// ===== MOVE TOOL STATE =====
let moveTarget = null, moveStartSvg = null, moveOrigTransform = null;

// ===== MOUSE EVENTS =====
mc.addEventListener('mousedown', e => {
  if (e.target.closest('#info,#ctrls,#toolbar')) return;

  // Move tool ‚Äî start drag on draw element
  if (activeTool === 'move' && e.target !== drawSvg && drawSvg.contains(e.target)) {
    e.preventDefault();
    moveTarget = e.target;
    moveTarget.classList.add('dragging');
    moveStartSvg = screenToSvg(e.clientX, e.clientY);
    // Parse existing transform
    const t = moveTarget.getAttribute('transform') || '';
    const m = t.match(/translate\(([-\d.]+),([-\d.]+)\)/);
    moveOrigTransform = m ? [parseFloat(m[1]), parseFloat(m[2])] : [0, 0];
    return;
  }

  if (activeTool === 'screenshot') {
    e.preventDefault();
    selecting = true;
    const r = mc.getBoundingClientRect();
    selStart = { x: e.clientX - r.left, y: e.clientY - r.top };
    const sel = document.getElementById('sel-rect');
    sel.style.left = selStart.x + 'px'; sel.style.top = selStart.y + 'px';
    sel.style.width = '0'; sel.style.height = '0'; sel.style.display = 'block';
    return;
  }

  if (activeTool === 'pan') {
    drag=true; sx=e.clientX-px; sy=e.clientY-py; mc.classList.add('drag'); e.preventDefault();
    return;
  }

  // Eraser tool: click dots/text/ruler to delete, or draw to partially erase pen/hl
  if (activeTool === 'eraser') {
    e.preventDefault();
    const clicked = e.target;
    // Check if clicked on a ruler/measure element ‚Äî erase entire measurement
    if (measureGroup && (measureGroup.contains(clicked) || measureLabels.some(l => l === clicked || l.contains(clicked)))) {
      clearMeasure();
      toast('Ruler erased');
      return;
    }
    // Check if clicked a dot group child (circle or text inside a <g>)
    let found = null;
    if (clicked !== drawSvg && drawSvg.contains(clicked)) {
      // Walk up to find a drawHistory entry
      let el = clicked;
      while (el && el !== drawSvg) {
        if (drawHistory.includes(el)) { found = el; break; }
        el = el.parentElement;
      }
    }
    if (found && found.tagName === 'g') {
      // It's a mark point group ‚Äî delete and release the number
      if (found._dotLabel) releaseDotNumber(found._dotLabel);
      else { const txt = found.querySelector('text'); if (txt) releaseDotNumber(txt.textContent); }
      const idx = drawHistory.indexOf(found);
      if (idx !== -1) drawHistory.splice(idx, 1);
      found.remove();
      updateAnnoCount();
      toast('Erased');
      return;
    }
    // Also allow erasing standalone text annotations
    if (found && found.tagName === 'text') {
      const idx = drawHistory.indexOf(found);
      if (idx !== -1) drawHistory.splice(idx, 1);
      found.remove();
      updateAnnoCount();
      toast('Erased');
      return;
    }
    // Otherwise start drawing an erase stroke on the mask
    drawing = true;
    const [svgX, svgY] = screenToSvg(e.clientX, e.clientY);
    curPath = document.createElementNS('http://www.w3.org/2000/svg','path');
    curPath.setAttribute('fill','none');
    curPath.setAttribute('stroke','black');
    curPath.setAttribute('stroke-linecap','round');
    curPath.setAttribute('stroke-linejoin','round');
    curPath.setAttribute('stroke-width', drawSize * 8);
    curPath._pts = `M${svgX.toFixed(1)},${svgY.toFixed(1)}`;
    curPath.setAttribute('d', curPath._pts);
    curPath._isEraserMask = true;
    eraseMask.appendChild(curPath);
    drawHistory.push(curPath);
    updateAnnoCount();
    spawnEraserStamp(e.clientX, e.clientY);
    return;
  }

  if (activeTool === 'move') return;

  e.preventDefault();
  const [svgX, svgY] = screenToSvg(e.clientX, e.clientY);

  if (activeTool === 'pen' || activeTool === 'hl') {
    drawing = true;
    curPath = document.createElementNS('http://www.w3.org/2000/svg','path');
    curPath.setAttribute('fill','none');
    curPath.setAttribute('stroke-linecap','round');
    curPath.setAttribute('stroke-linejoin','round');
    if (activeTool === 'hl') {
      curPath.setAttribute('stroke', '#ffff00'); // Always yellow
      curPath.setAttribute('stroke-width', drawSize * 6);
      curPath.setAttribute('opacity','0.35');
    } else {
      curPath.setAttribute('stroke', drawColor);
      curPath.setAttribute('stroke-width', drawSize);
    }
    curPath._pts = `M${svgX.toFixed(1)},${svgY.toFixed(1)}`;
    curPath.setAttribute('d', curPath._pts);
    drawStrokes.appendChild(curPath);
    drawHistory.push(curPath);
    updateAnnoCount();
  } else if (activeTool === 'text') {
    openInlineTextEditor(svgX, svgY, drawColor, drawSize * 8, null);
  } else if (activeTool === 'dot') {
    const pNum = getNextDotNumber();
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g._dotLabel = 'P' + pNum;
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', svgX); c.setAttribute('cy', svgY);
    c.setAttribute('r', drawSize * 3);
    c.setAttribute('fill', '#00d4ff');
    c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width', 2);
    c.setAttribute('opacity','0.9');
    g.appendChild(c);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', svgX); t.setAttribute('y', svgY - drawSize * 3 - 10);
    t.setAttribute('fill', '#00d4ff');
    t.setAttribute('font-size', Math.max(28, drawSize * 6));
    t.setAttribute('font-weight','800');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-family','Segoe UI, system-ui, sans-serif');
    t.setAttribute('paint-order','stroke');
    t.setAttribute('stroke','rgba(0,0,0,0.8)');
    t.setAttribute('stroke-width','4px');
    t.textContent = 'P' + pNum;
    g.appendChild(t);
    drawSvg.appendChild(g);
    drawHistory.push(g);
    updateAnnoCount();
    toast('P' + pNum + ' placed');
  }
});

window.addEventListener('mousemove', e => {
  // Screenshot selection drag
  if (selecting && selStart) {
    const r = mc.getBoundingClientRect();
    const cx = e.clientX - r.left, cy = e.clientY - r.top;
    const sel = document.getElementById('sel-rect');
    sel.style.left = Math.min(selStart.x, cx) + 'px';
    sel.style.top = Math.min(selStart.y, cy) + 'px';
    sel.style.width = Math.abs(cx - selStart.x) + 'px';
    sel.style.height = Math.abs(cy - selStart.y) + 'px';
    return;
  }
  // Move tool drag
  if (moveTarget) {
    const [svgX, svgY] = screenToSvg(e.clientX, e.clientY);
    const dx = svgX - moveStartSvg[0] + moveOrigTransform[0];
    const dy = svgY - moveStartSvg[1] + moveOrigTransform[1];
    moveTarget.setAttribute('transform', `translate(${dx.toFixed(1)},${dy.toFixed(1)})`);
    return;
  }
  if (drag && activeTool === 'pan') { px=e.clientX-sx; py=e.clientY-sy; upd(); return; }
  if (drawing && curPath) {
    const [svgX, svgY] = screenToSvg(e.clientX, e.clientY);
    curPath._pts += ` L${svgX.toFixed(1)},${svgY.toFixed(1)}`;
    curPath.setAttribute('d', curPath._pts);
    // Spawn visual eraser stamps
    if (curPath._isEraserMask) spawnEraserStamp(e.clientX, e.clientY);
  }
});

window.addEventListener('mouseup', e => {
  // Screenshot capture
  if (selecting && selStart) {
    selecting = false;
    const sel = document.getElementById('sel-rect');
    sel.style.display = 'none';
    const r = mc.getBoundingClientRect();
    const cx = e.clientX - r.left, cy = e.clientY - r.top;
    const x1 = Math.min(selStart.x, cx), y1 = Math.min(selStart.y, cy);
    const w = Math.abs(cx - selStart.x), h = Math.abs(cy - selStart.y);
    if (w < 10 || h < 10) { toast('Selection too small'); setTool('pan'); return; }
    captureArea(x1, y1, w, h);
    return;
  }
  if (moveTarget) { moveTarget.classList.remove('dragging'); moveTarget = null; }
  drag=false; mc.classList.remove('drag');
  drawing = false; curPath = null;
});

// ===== SCREENSHOT CAPTURE (fixed) =====
let screenshotCounter = 0;
function getScreenshotFilename() {
  screenshotCounter++;
  // Central Time = UTC - 6 (CST) or UTC - 5 (CDT)
  // Use America/Chicago timezone
  const now = new Date();
  const ct = new Date(now.toLocaleString('en-US', { timeZone: 'America/Chicago' }));
  const mm = String(ct.getMonth() + 1).padStart(2, '0');
  const dd = String(ct.getDate()).padStart(2, '0');
  const yyyy = ct.getFullYear();
  const hh = String(ct.getHours()).padStart(2, '0');
  const min = String(ct.getMinutes()).padStart(2, '0');
  return `twinlakesrma-map-screenshot-${mm}-${dd}-${yyyy}-screenshot${screenshotCounter}-${hh}${min}.png`;
}

function captureArea(sx, sy, sw, sh) {
  toast('Capturing...');
  const svgX1 = (sx - px) / scale;
  const svgY1 = (sy - py) / scale;
  const svgW = sw / scale;
  const svgH = sh / scale;

  const dpr = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas');
  canvas.width = Math.round(sw * dpr);
  canvas.height = Math.round(sh * dpr);
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // Draw plat image ‚Äî use a temp canvas to avoid cross-origin taint
  // We re-draw from the loaded image. If img is same-origin it works directly.
  try { ctx.drawImage(img, svgX1, svgY1, svgW, svgH, 0, 0, sw, sh); } catch(e) { /* continue without base image */ }

  // Render SVG overlays via foreignObject-free serialization
  function renderSvgToCanvas(svgEl) {
    return new Promise(resolve => {
      try {
        const clone = svgEl.cloneNode(true);
        clone.setAttribute('viewBox', `${svgX1} ${svgY1} ${svgW} ${svgH}`);
        clone.setAttribute('width', sw);
        clone.setAttribute('height', sh);
        clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

        // Inline computed styles so labels/text survive serialization
        // Walk the ORIGINAL SVG elements and copy their computed styles onto cloned counterparts
        const origEls = svgEl.querySelectorAll('circle, text, path, line, rect, g');
        const cloneEls = clone.querySelectorAll('circle, text, path, line, rect, g');
        const styleProps = ['opacity','fill','stroke','stroke-width','font-size','font-weight',
          'font-family','text-anchor','dominant-baseline','paint-order','stroke-dasharray',
          'stroke-linecap','stroke-linejoin','display','visibility'];
        for (let i = 0; i < origEls.length && i < cloneEls.length; i++) {
          const cs = window.getComputedStyle(origEls[i]);
          const ce = cloneEls[i];
          styleProps.forEach(prop => {
            const val = cs.getPropertyValue(prop);
            if (val && val !== '' && val !== 'none' && val !== 'normal') {
              // For display:none or visibility:hidden, skip element entirely
              if (prop === 'display' && val === 'none') { ce.setAttribute('display','none'); return; }
              if (prop === 'visibility' && val === 'hidden') { ce.setAttribute('visibility','hidden'); return; }
              // Set as SVG attribute (these override CSS in standalone SVG)
              if (prop === 'font-size' || prop === 'font-weight' || prop === 'font-family') {
                ce.setAttribute(prop, val);
              } else if (prop === 'paint-order') {
                ce.style.paintOrder = val;
              } else {
                ce.setAttribute(prop, val);
              }
            }
          });
          // Force hidden elements with opacity 0 (like non-.show lot-labels) to stay hidden
          // But show elements that HAVE the .show class
          if (origEls[i].classList.contains('lot-label') || origEls[i].classList.contains('rp-label')) {
            const computedOpacity = cs.getPropertyValue('opacity');
            ce.setAttribute('opacity', computedOpacity);
          }
        }

        const data = new XMLSerializer().serializeToString(clone);
        const svgImg = new Image();
        svgImg.onload = () => { ctx.drawImage(svgImg, 0, 0, sw, sh); resolve(); };
        svgImg.onerror = () => resolve();
        svgImg.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(data);
      } catch(e) { resolve(); }
    });
  }

  const ssFilename = getScreenshotFilename();
  renderSvgToCanvas(svg).then(() => renderSvgToCanvas(drawSvg)).then(() => {
    // Try toDataURL first (more reliable cross-browser), fallback to toBlob
    try {
      const dataUrl = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = ssFilename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      toast('Screenshot saved!');
      setTool('pan');
    } catch(e) {
      // Fallback: try toBlob
      try {
        canvas.toBlob(blob => {
          if (!blob) { toast('Screenshot failed ‚Äî try again'); setTool('pan'); return; }
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = ssFilename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
          toast('Screenshot saved!');
          setTool('pan');
        }, 'image/png');
      } catch(e2) {
        toast('Screenshot failed ‚Äî cross-origin restriction');
        setTool('pan');
      }
    }
  });
}

// ===== MEASURE TOOL (multi-point) =====
let measurePoints = []; // array of {x, y} in SVG coords
let measureGroup = null; // SVG <g> holding all lines/dots/labels
let measureLabels = []; // SVG text labels for each segment

function clearMeasure() {
  if (measureGroup) { measureGroup.remove(); measureGroup = null; }
  measureLabels.forEach(l => l.remove());
  measureLabels = [];
  document.getElementById('measure-info').classList.remove('show');
  measurePoints = [];
}

function createMeasureDot(svgX, svgY) {
  const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
  c.setAttribute('cx', svgX); c.setAttribute('cy', svgY); c.setAttribute('r', 8);
  c.setAttribute('fill','#00d4ff'); c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width', 2);
  return c;
}

function updateMeasureInfo() {
  if (measurePoints.length < 2) {
    document.getElementById('measure-info').classList.remove('show');
    return;
  }
  let totalDist = 0;
  const segments = [];
  for (let i = 1; i < measurePoints.length; i++) {
    const dx = measurePoints[i].x - measurePoints[i-1].x;
    const dy = measurePoints[i].y - measurePoints[i-1].y;
    const d = Math.sqrt(dx*dx + dy*dy);
    totalDist += d;
    segments.push(Math.round(d));
  }
  const pctDist = (totalDist / Math.sqrt(IW*IW+IH*IH) * 100).toFixed(2);
  let html = `üìè <strong>Total: ${Math.round(totalDist)} px</strong> &nbsp;|&nbsp; ${measurePoints.length} points, ${segments.length} segment${segments.length!==1?'s':''} &nbsp;|&nbsp; ~${pctDist}% of map diagonal`;
  if (segments.length > 1) html += `<br><span style="font-size:10px;color:#8b949e">Segments: ${segments.map((s,i) => (i+1)+':'+s+'px').join(' ¬∑ ')}</span>`;
  document.getElementById('measure-info').innerHTML = html;
  document.getElementById('measure-info').classList.add('show');
}

function addMeasurePoint(svgX, svgY) {
  if (!measureGroup) {
    measureGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    measureGroup.id = 'measure-line';
    drawSvg.appendChild(measureGroup);
  }
  const prevPt = measurePoints.length > 0 ? measurePoints[measurePoints.length - 1] : null;
  measurePoints.push({ x: svgX, y: svgY });

  // Draw dot
  measureGroup.appendChild(createMeasureDot(svgX, svgY));

  // Draw line segment from previous point
  if (prevPt) {
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', prevPt.x); line.setAttribute('y1', prevPt.y);
    line.setAttribute('x2', svgX); line.setAttribute('y2', svgY);
    line.setAttribute('stroke','#00d4ff'); line.setAttribute('stroke-width', 4);
    line.setAttribute('stroke-dasharray','12,6');
    // Insert lines before dots so dots render on top
    measureGroup.insertBefore(line, measureGroup.firstChild);

    // Segment distance label at midpoint
    const dx = svgX - prevPt.x, dy = svgY - prevPt.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const mx = (prevPt.x + svgX) / 2, my = (prevPt.y + svgY) / 2;
    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', mx); label.setAttribute('y', my - 14);
    label.setAttribute('font-size', '14');
    label.setAttribute('font-weight', '800');
    label.setAttribute('fill', '#00d4ff');
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('dominant-baseline', 'central');
    label.style.paintOrder = 'stroke';
    label.setAttribute('stroke', '#000');
    label.setAttribute('stroke-width', '3px');
    label.setAttribute('pointer-events', 'auto');
    label.textContent = Math.round(dist) + ' px';
    drawSvg.appendChild(label);
    measureLabels.push(label);
  }

  updateMeasureInfo();

  if (measurePoints.length === 1) {
    toast('Click to add points ¬∑ Double-click to finish');
  }
}

mc.addEventListener('mousedown', e => {
  if (activeTool !== 'measure') return;
  if (e.target.closest('#info,#ctrls,#toolbar,#legend-panel,#measure-info')) return;
  e.preventDefault();
  e.stopPropagation();
  const [svgX, svgY] = screenToSvg(e.clientX, e.clientY);
  addMeasurePoint(svgX, svgY);
}, true); // capture phase so it fires before pan handler

mc.addEventListener('dblclick', e => {
  if (activeTool !== 'measure') return;
  if (e.target.closest('#info,#ctrls,#toolbar,#legend-panel,#measure-info')) return;
  e.preventDefault();
  // Double-click finishes the measurement (the two single clicks already added points)
  if (measurePoints.length >= 2) {
    toast('Measurement complete ¬∑ Ruler stays visible ¬∑ Use eraser to remove');
  }
  // Stop adding points ‚Äî user can click Ruler again or press R to clear and restart
  setTool('pan');
}, true);

// Read share hash on load
function applyShareHash() {
  const h = window.location.hash;
  if (!h.startsWith('#v=')) return;
  const parts = h.slice(3).split(',').map(Number);
  if (parts.length === 3 && parts.every(n => !isNaN(n))) {
    const [z, cxPct, cyPct] = parts;
    scale = z;
    const targetX = cxPct / 100 * IW;
    const targetY = cyPct / 100 * IH;
    px = mc.clientWidth / 2 - targetX * scale;
    py = mc.clientHeight / 2 - targetY * scale;
    upd();
  }
}

// ===== LEGEND PANEL =====
const legendPanel = document.getElementById('legend-panel');
const legendMinBtn = document.getElementById('legend-minimize');
// Legend toggle button shows/hides the full panel
document.getElementById('legend-btn').onclick = () => {
  legendPanel.classList.toggle('show');
};
// Minimize toggle ‚Äî collapse body but keep header visible
legendMinBtn.onclick = (e) => {
  e.stopPropagation();
  legendPanel.classList.toggle('minimized');
  legendMinBtn.textContent = legendPanel.classList.contains('minimized') ? '‚ñ∏' : '‚ñæ';
};
// Also clicking the header toggles minimize
document.querySelector('.legend-hdr').onclick = () => {
  legendPanel.classList.toggle('minimized');
  legendMinBtn.textContent = legendPanel.classList.contains('minimized') ? '‚ñ∏' : '‚ñæ';
};

// ===== WHEEL ZOOM =====
mc.addEventListener('wheel', e => {
  e.preventDefault();
  const r=mc.getBoundingClientRect(), mx=e.clientX-r.left, my=e.clientY-r.top;
  const f=e.deltaY>0?0.9:1.1, ns=Math.max(0.08,Math.min(12,scale*f));
  px=mx-(mx-px)*(ns/scale); py=my-(my-py)*(ns/scale); scale=ns; upd();
  updateEraserCursorSize();
}, {passive:false});

// ===== TOUCH (pan + pinch + draw) =====
let ltd=0, touchDrawing=false, touchPath=null;
mc.addEventListener('touchstart', e => {
  if (e.target.closest('#info,#ctrls,#toolbar,#legend-panel,#modal-overlay')) return;

  if (e.touches.length === 2) {
    // Pinch zoom ‚Äî always works regardless of tool
    touchDrawing = false; touchPath = null;
    ltd = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    return;
  }

  if (e.touches.length === 1) {
    if (activeTool === 'eraser') {
      // Check if touch landed on ruler ‚Äî erase entire measurement
      const touchEl = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
      if (measureGroup && (measureGroup.contains(touchEl) || measureLabels.some(l => l === touchEl || l.contains(touchEl)))) {
        clearMeasure();
        toast('Ruler erased');
        return;
      }
      // Check if touch landed on a dot group or text annotation
      let found = null;
      if (touchEl && touchEl !== drawSvg && drawSvg.contains(touchEl)) {
        let el = touchEl;
        while (el && el !== drawSvg) {
          if (drawHistory.includes(el)) { found = el; break; }
          el = el.parentElement;
        }
      }
      if (found && (found.tagName === 'g' || found.tagName === 'text')) {
        if (found.tagName === 'g') {
          if (found._dotLabel) releaseDotNumber(found._dotLabel);
          else { const txt = found.querySelector('text'); if (txt) releaseDotNumber(txt.textContent); }
        }
        const idx = drawHistory.indexOf(found);
        if (idx !== -1) drawHistory.splice(idx, 1);
        found.remove();
        updateAnnoCount();
        toast('Erased');
        return;
      }
      // Start drawing erase mask stroke
      const [svgX, svgY] = screenToSvg(e.touches[0].clientX, e.touches[0].clientY);
      touchDrawing = true;
      touchPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      touchPath.setAttribute('fill','none');
      touchPath.setAttribute('stroke','black');
      touchPath.setAttribute('stroke-linecap','round');
      touchPath.setAttribute('stroke-linejoin','round');
      touchPath.setAttribute('stroke-width', drawSize * 8);
      touchPath._pts = `M${svgX.toFixed(1)},${svgY.toFixed(1)}`;
      touchPath.setAttribute('d', touchPath._pts);
      touchPath._isEraserMask = true;
      eraseMask.appendChild(touchPath);
      drawHistory.push(touchPath);
      updateAnnoCount();
      spawnEraserStamp(e.touches[0].clientX, e.touches[0].clientY);
    } else if (activeTool === 'pan' || activeTool === 'move') {
      drag=true; sx=e.touches[0].clientX-px; sy=e.touches[0].clientY-py;
    } else if (activeTool === 'pen' || activeTool === 'hl') {
      const [svgX, svgY] = screenToSvg(e.touches[0].clientX, e.touches[0].clientY);
      touchDrawing = true;
      touchPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      touchPath.setAttribute('fill','none');
      touchPath.setAttribute('stroke-linecap','round');
      touchPath.setAttribute('stroke-linejoin','round');
      if (activeTool === 'hl') {
        touchPath.setAttribute('stroke', '#ffff00');
        touchPath.setAttribute('stroke-width', drawSize * 6);
        touchPath.setAttribute('opacity','0.35');
      } else {
        touchPath.setAttribute('stroke', drawColor);
        touchPath.setAttribute('stroke-width', drawSize);
      }
      touchPath._pts = `M${svgX.toFixed(1)},${svgY.toFixed(1)}`;
      touchPath.setAttribute('d', touchPath._pts);
      drawStrokes.appendChild(touchPath);
      drawHistory.push(touchPath);
      updateAnnoCount();
    } else if (activeTool === 'dot') {
      const pNum = getNextDotNumber();
      const [svgX, svgY] = screenToSvg(e.touches[0].clientX, e.touches[0].clientY);
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g._dotLabel = 'P' + pNum;
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', svgX); c.setAttribute('cy', svgY);
      c.setAttribute('r', drawSize * 3);
      c.setAttribute('fill', '#00d4ff');
      c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width', 2);
      c.setAttribute('opacity','0.9');
      g.appendChild(c);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', svgX); t.setAttribute('y', svgY - drawSize * 3 - 10);
      t.setAttribute('fill', '#00d4ff');
      t.setAttribute('font-size', Math.max(28, drawSize * 6));
      t.setAttribute('font-weight','800');
      t.setAttribute('text-anchor','middle');
      t.setAttribute('font-family','Segoe UI, system-ui, sans-serif');
      t.setAttribute('paint-order','stroke');
      t.setAttribute('stroke','rgba(0,0,0,0.8)');
      t.setAttribute('stroke-width','4px');
      t.textContent = 'P' + pNum;
      g.appendChild(t);
      drawSvg.appendChild(g);
      drawHistory.push(g);
      updateAnnoCount();
      toast('P' + pNum + ' placed');
    }
  }
  // Prevent browser zoom ‚Äî let our map handle all touch gestures
  if (e.touches.length >= 2) e.preventDefault();
}, {passive:false});

mc.addEventListener('touchmove', e => {
  // Prevent browser zoom/scroll on the map area
  e.preventDefault();
  if (e.touches.length === 1) {
    if (drag) { px=e.touches[0].clientX-sx; py=e.touches[0].clientY-sy; upd(); }
    if (touchDrawing && touchPath) {
      const [svgX, svgY] = screenToSvg(e.touches[0].clientX, e.touches[0].clientY);
      touchPath._pts += ` L${svgX.toFixed(1)},${svgY.toFixed(1)}`;
      touchPath.setAttribute('d', touchPath._pts);
      if (touchPath._isEraserMask) spawnEraserStamp(e.touches[0].clientX, e.touches[0].clientY);
    }
  }
  if (e.touches.length === 2) {
    const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    const r=d/ltd; ltd=d; const ns=Math.max(0.08,Math.min(12,scale*r));
    const mx=(e.touches[0].clientX+e.touches[1].clientX)/2-mc.getBoundingClientRect().left;
    const my=(e.touches[0].clientY+e.touches[1].clientY)/2-mc.getBoundingClientRect().top;
    px=mx-(mx-px)*(ns/scale); py=my-(my-py)*(ns/scale); scale=ns; upd();
  }
}, {passive:false});

mc.addEventListener('touchend', () => { drag=false; touchDrawing=false; touchPath=null; });

// Click background to deselect
mc.addEventListener('click', e => {
  if (activeTool !== 'pan') return;
  if (e.target===mc||e.target===mw||e.target===img) closeInfo();
});

// ===== INLINE TEXT EDITOR =====
let activeTextEditor = null;
function openInlineTextEditor(svgX, svgY, color, fontSize, existingTextEl) {
  if (activeTextEditor) closeInlineTextEditor(true); // commit any open editor
  const wrapEl = document.getElementById('wrap');
  // Convert SVG coords to screen px relative to #map
  const screenX = svgX * scale + px;
  const screenY = svgY * scale + py;
  const screenFontSize = Math.max(12, fontSize * scale);

  const editor = document.createElement('div');
  editor.contentEditable = 'true';
  editor.className = 'inline-text-editor';
  editor.style.cssText = `
    position:absolute;left:${screenX}px;top:${screenY - screenFontSize * 1.1}px;
    font-size:${screenFontSize}px;font-weight:700;font-family:'Segoe UI',system-ui,sans-serif;
    color:${color};min-width:40px;min-height:${screenFontSize + 4}px;
    outline:none;border:2px solid #58a6ff;border-radius:3px;
    background:rgba(0,0,0,0.3);padding:2px 4px;white-space:pre-wrap;
    z-index:20;line-height:1.2;cursor:text;
  `;
  if (existingTextEl) {
    // Populate from existing SVG text (may have tspans for multiline)
    const tspans = existingTextEl.querySelectorAll('tspan');
    if (tspans.length > 0) {
      editor.innerText = Array.from(tspans).map(ts => ts.textContent).join('\n');
    } else {
      editor.innerText = existingTextEl.textContent;
    }
  }
  mc.appendChild(editor);
  editor.focus();

  // Select all text in editor for easy replacement
  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNodeContents(editor);
  sel.removeAllRanges();
  sel.addRange(range);

  activeTextEditor = {
    el: editor, svgX, svgY, color, fontSize, existingTextEl
  };

  // Escape to cancel, click-away to commit
  editor._onKeyDown = (e) => {
    if (e.key === 'Escape') { e.preventDefault(); closeInlineTextEditor(false); }
    // Shift+Enter inserts newline (default contentEditable behavior)
    // Enter alone commits the text
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); closeInlineTextEditor(true); }
    e.stopPropagation(); // prevent keyboard shortcuts
  };
  editor._onBlur = () => {
    setTimeout(() => closeInlineTextEditor(true), 100);
  };
  editor.addEventListener('keydown', editor._onKeyDown);
  editor.addEventListener('blur', editor._onBlur);
}

function closeInlineTextEditor(commit) {
  if (!activeTextEditor) return;
  const { el, svgX, svgY, color, fontSize, existingTextEl } = activeTextEditor;
  activeTextEditor = null;
  el.removeEventListener('keydown', el._onKeyDown);
  el.removeEventListener('blur', el._onBlur);
  const rawText = el.innerText.trim();
  el.remove();

  if (!commit || !rawText) {
    // If editing existing and cancelled or empty, remove it if empty
    if (existingTextEl && !rawText && commit) {
      const idx = drawHistory.indexOf(existingTextEl);
      if (idx !== -1) drawHistory.splice(idx, 1);
      existingTextEl.remove();
      updateAnnoCount();
    }
    return;
  }

  const lines = rawText.split('\n');

  if (existingTextEl) {
    // Update existing text element
    existingTextEl.textContent = '';
    if (lines.length === 1) {
      existingTextEl.textContent = lines[0];
    } else {
      lines.forEach((line, i) => {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
        tspan.setAttribute('x', existingTextEl.getAttribute('x'));
        if (i === 0) {
          tspan.setAttribute('dy', '0');
        } else {
          tspan.setAttribute('dy', '1.2em');
        }
        tspan.textContent = line;
        existingTextEl.appendChild(tspan);
      });
    }
  } else {
    // Create new text element
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', svgX); t.setAttribute('y', svgY);
    t.setAttribute('fill', color);
    t.setAttribute('font-size', fontSize);
    t.setAttribute('font-weight','700');
    t.setAttribute('font-family','Segoe UI, system-ui, sans-serif');
    t._isUserText = true;
    if (lines.length === 1) {
      t.textContent = lines[0];
    } else {
      lines.forEach((line, i) => {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
        tspan.setAttribute('x', svgX);
        if (i === 0) {
          tspan.setAttribute('dy', '0');
        } else {
          tspan.setAttribute('dy', '1.2em');
        }
        tspan.textContent = line;
        t.appendChild(tspan);
      });
    }
    drawSvg.appendChild(t);
    drawHistory.push(t);
    updateAnnoCount();
  }
}

// Double-click on existing text to edit
drawSvg.addEventListener('dblclick', (e) => {
  if (activeTool === 'measure') return; // don't interfere with measure double-click
  let target = e.target;
  // Walk up if we clicked a tspan
  if (target.tagName === 'tspan') target = target.parentElement;
  // Check if it's a user text annotation in drawHistory
  if (target.tagName === 'text' && drawHistory.includes(target)) {
    e.preventDefault(); e.stopPropagation();
    const x = parseFloat(target.getAttribute('x'));
    const y = parseFloat(target.getAttribute('y'));
    const color = target.getAttribute('fill') || drawColor;
    const fontSize = parseFloat(target.getAttribute('font-size')) || drawSize * 8;
    openInlineTextEditor(x, y, color, fontSize, target);
  }
});

// ===== UNDO / CLEAR =====
document.getElementById('undo-btn').onclick = () => {
  if (!drawHistory.length) return;
  const last = drawHistory.pop();
  // Release mark point number if it was a dot group
  if (last.tagName === 'g') {
    if (last._dotLabel) releaseDotNumber(last._dotLabel);
    else { const txt = last.querySelector('text'); if (txt) releaseDotNumber(txt.textContent); }
  }
  last.remove();
  updateAnnoCount();
  toast('Undo');
};
document.getElementById('clear-btn').onclick = () => {
  if (!drawHistory.length) return;
  drawHistory.forEach(el => el.remove());
  drawHistory = [];
  dotCounter = 0;
  usedDotNumbers.clear();
  // Also clear any eraser mask strokes (black paths in eraseMask)
  eraseMask.querySelectorAll('path').forEach(p => p.remove());
  // Clear ruler measurement too
  if (typeof clearMeasure === 'function') clearMeasure();
  updateAnnoCount();
  toast('Annotations cleared');
};

// ===== ZOOM CONTROLS =====
document.getElementById('zi').onclick = () => {
  const cw=mc.clientWidth/2,ch=mc.clientHeight/2,ns=Math.min(12,scale*1.4);
  px=cw-(cw-px)*(ns/scale);py=ch-(ch-py)*(ns/scale);scale=ns;upd();
};
document.getElementById('zo').onclick = () => {
  const cw=mc.clientWidth/2,ch=mc.clientHeight/2,ns=Math.max(0.08,scale/1.4);
  px=cw-(cw-px)*(ns/scale);py=ch-(ch-py)*(ns/scale);scale=ns;upd();
};
document.getElementById('zr').onclick = fit;
document.getElementById('zc').onclick = centerView;

// ===== KEYBOARD =====
document.addEventListener('keydown', e => {
  if (e.target.tagName==='INPUT'||e.target.tagName==='TEXTAREA') return;
  if (e.key==='Escape') closeInfo();
  if (e.key==='+'||e.key==='=') document.getElementById('zi').click();
  if (e.key==='-') document.getElementById('zo').click();
  if (e.key==='0') document.getElementById('zr').click();
  const noMod = !e.ctrlKey && !e.metaKey;
  if (e.key==='v'&&noMod) setTool('pan');
  if (e.key==='p'&&noMod) setTool('pen');
  if (e.key==='h'&&noMod) setTool('hl');
  if (e.key==='t'&&noMod) setTool('text');
  if (e.key==='d'&&noMod) setTool('dot');
  if (e.key==='m'&&noMod) setTool('move');
  if (e.key==='e'&&noMod) setTool('eraser');
  if (e.key==='r'&&noMod) setTool('measure');
  if (e.key==='s'&&noMod) setTool('screenshot');
  if (e.key==='i'&&noMod) document.getElementById('info-btn').click();
  if (e.key==='c'&&noMod) centerView();
  if ((e.ctrlKey||e.metaKey) && e.key==='z') { e.preventDefault(); document.getElementById('undo-btn').click(); }
});

// ===== HELPERS =====
function mk(tag,cls){const e=document.createElement(tag);e.className=cls;return e;}
let tt;
function toast(m){const t=document.getElementById('toast');t.textContent=m;t.classList.add('show');clearTimeout(tt);tt=setTimeout(()=>t.classList.remove('show'),2200);}

// ===== WELCOME MODAL =====
const modalOverlay = document.getElementById('modal-overlay');
function closeModal() {
  modalOverlay.classList.add('hidden');
  setTimeout(() => { modalOverlay.style.display = 'none'; }, 300);
}
document.getElementById('modal-continue').onclick = closeModal;
// Fix mobile: ensure touch works on continue button
document.getElementById('modal-continue').addEventListener('touchend', (e) => {
  e.preventDefault();
  closeModal();
}, {passive:false});
document.getElementById('info-btn').onclick = () => {
  modalOverlay.classList.add('no-backdrop');
  modalOverlay.style.display = 'flex';
  requestAnimationFrame(() => { modalOverlay.classList.remove('hidden'); });
};
// Close modal on overlay click (not modal itself)
modalOverlay.addEventListener('click', e => {
  if (e.target === modalOverlay) closeModal();
});


// ===== MINIMAP =====
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');
const minimapEl = document.getElementById('minimap');
const minimapVp = document.getElementById('minimap-vp');

function drawMinimap() {
  const cw = minimapEl.clientWidth, ch = minimapEl.clientHeight;
  minimapCanvas.width = cw * 2; minimapCanvas.height = ch * 2;
  minimapCtx.scale(2, 2);
  // Draw background
  minimapCtx.fillStyle = '#d5d0c4';
  minimapCtx.fillRect(0, 0, cw, ch);
  // Draw plat image scaled
  try { minimapCtx.drawImage(img, 0, 0, cw, ch); } catch(e) {}
  // Draw road point dots
  for (const g in ROAD_POINTS) {
    const color = ROAD_POINTS[g].color;
    ROAD_POINTS[g].points.forEach(pt => {
      pt.dots.forEach(([cxp,cyp]) => {
        minimapCtx.fillStyle = color;
        minimapCtx.beginPath();
        minimapCtx.arc(cxp/100*cw, cyp/100*ch, 2, 0, Math.PI*2);
        minimapCtx.fill();
      });
    });
  }
}

function updateMinimapViewport() {
  if (minimapEl.classList.contains('collapsed')) return;
  const mw2 = minimapEl.clientWidth, mh = minimapEl.clientHeight;
  const mapW = mc.clientWidth, mapH = mc.clientHeight;
  // Calculate what portion of the image is visible
  const vx = -px / scale / IW * mw2;
  const vy = -py / scale / IH * mh;
  const vw = mapW / scale / IW * mw2;
  const vh = mapH / scale / IH * mh;
  minimapVp.style.left = Math.max(0, vx) + 'px';
  minimapVp.style.top = Math.max(0, vy) + 'px';
  minimapVp.style.width = Math.min(mw2, vw) + 'px';
  minimapVp.style.height = Math.min(mh, vh) + 'px';
}

// Override upd to also update minimap + coords
const _origUpd = upd;
function upd() {
  mw.style.transform = `translate(${px}px,${py}px) scale(${scale})`;
  updateMinimapViewport();
  updateCoordDisplay();
}

// Click minimap to navigate
minimapEl.addEventListener('click', e => {
  if (e.target === document.getElementById('minimap-toggle')) return;
  const rect = minimapEl.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;
  // Center the map view on this point
  const targetX = mx * IW;
  const targetY = my * IH;
  px = mc.clientWidth / 2 - targetX * scale;
  py = mc.clientHeight / 2 - targetY * scale;
  upd();
});

document.getElementById('minimap-toggle').onclick = e => {
  e.stopPropagation();
  minimapEl.classList.toggle('collapsed');
  if (!minimapEl.classList.contains('collapsed')) {
    setTimeout(() => { drawMinimap(); updateMinimapViewport(); }, 50);
  }
};

img.addEventListener('load', () => setTimeout(drawMinimap, 200));
if (img.complete) setTimeout(drawMinimap, 200);

// ===== COORDINATE DISPLAY =====
let lastMouseSvg = null;
const coordDisplay = document.getElementById('coord-display');

function updateCoordDisplay() {
  const coordX = document.getElementById('coord-x');
  const coordY = document.getElementById('coord-y');
  const coordZ = document.getElementById('coord-z');
  // Don't overwrite while user is editing
  if (document.activeElement === coordX || document.activeElement === coordY || document.activeElement === coordZ) return;
  if (lastMouseSvg) {
    coordX.value = (lastMouseSvg[0] / IW * 100).toFixed(1) + '%';
    coordY.value = (lastMouseSvg[1] / IH * 100).toFixed(1) + '%';
  }
  coordZ.value = (scale * 100).toFixed(0) + '%';
}

mc.addEventListener('mousemove', e => {
  lastMouseSvg = screenToSvg(e.clientX, e.clientY);
  coordDisplay.classList.add('show');
  updateCoordDisplay();
});

// ===== SEARCH HIGHLIGHT ON MAP =====
let searchGlowEls = [];
function clearSearchGlow() {
  searchGlowEls.forEach(el => { el.classList.remove('search-glow'); if (el._wasHidden) el.style.display = 'none'; });
  searchGlowEls = [];
}

function applySearchGlow(query) {
  clearSearchGlow();
  if (!query || query.length < 1) return;
  const s = query.toLowerCase();
  for (const n in P) {
    const matchesNum = String(n).includes(s);
    const matchesOwner = (OWNERS[n] || '').toLowerCase().includes(s);
    if (matchesNum || matchesOwner) {
      if (lotDots[n]) lotDots[n].forEach(c => {
        const wasHidden = c.style.display === 'none';
        c._wasHidden = wasHidden;
        c.classList.add('search-glow');
        searchGlowEls.push(c);
      });
      if (lotLabels[n]) lotLabels[n].forEach(t => {
        t.classList.add('search-glow');
        searchGlowEls.push(t);
      });
    }
  }
}

// Hook into lot search
const origLotSearchHandler = document.getElementById('lot-search').oninput;
document.getElementById('lot-search').addEventListener('input', e => {
  applySearchGlow(e.target.value);
});

// ===== ANNOTATION SAVE / LOAD =====
function serializeAnnotations() {
  const data = [];
  drawHistory.forEach(el => {
    if (el._isEraserMask) return; // Skip eraser masks for now
    if (el.tagName === 'path' && !el._isEraserMask) {
      data.push({
        type: 'path',
        d: el.getAttribute('d'),
        stroke: el.getAttribute('stroke'),
        strokeWidth: el.getAttribute('stroke-width'),
        opacity: el.getAttribute('opacity'),
        strokeLinecap: el.getAttribute('stroke-linecap'),
        strokeLinejoin: el.getAttribute('stroke-linejoin'),
        fill: el.getAttribute('fill'),
        transform: el.getAttribute('transform')
      });
    } else if (el.tagName === 'text') {
      data.push({
        type: 'text',
        x: el.getAttribute('x'), y: el.getAttribute('y'),
        fill: el.getAttribute('fill'),
        fontSize: el.getAttribute('font-size'),
        fontWeight: el.getAttribute('font-weight'),
        fontFamily: el.getAttribute('font-family'),
        text: el.textContent,
        transform: el.getAttribute('transform')
      });
    } else if (el.tagName === 'g') {
      // Dot marker group (circle + text)
      const circle = el.querySelector('circle');
      const text = el.querySelector('text');
      if (circle && text) {
        data.push({
          type: 'dot',
          cx: circle.getAttribute('cx'), cy: circle.getAttribute('cy'),
          r: circle.getAttribute('r'),
          fill: circle.getAttribute('fill'),
          label: text.textContent,
          fontSize: text.getAttribute('font-size'),
          transform: el.getAttribute('transform')
        });
      }
    }
  });
  return data;
}

function loadAnnotations(data) {
  // Clear current
  drawHistory.forEach(el => el.remove());
  drawHistory = [];
  dotCounter = 0;
  usedDotNumbers.clear();
  eraseMask.querySelectorAll('path').forEach(p => p.remove());

  data.forEach(item => {
    if (item.type === 'path') {
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', item.d || '');
      p.setAttribute('fill', item.fill || 'none');
      p.setAttribute('stroke', item.stroke || '#ff4444');
      p.setAttribute('stroke-width', item.strokeWidth || '4');
      if (item.opacity) p.setAttribute('opacity', item.opacity);
      if (item.strokeLinecap) p.setAttribute('stroke-linecap', item.strokeLinecap);
      if (item.strokeLinejoin) p.setAttribute('stroke-linejoin', item.strokeLinejoin);
      if (item.transform) p.setAttribute('transform', item.transform);
      drawStrokes.appendChild(p);
      drawHistory.push(p);
    } else if (item.type === 'text') {
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', item.x); t.setAttribute('y', item.y);
      t.setAttribute('fill', item.fill || '#ff4444');
      t.setAttribute('font-size', item.fontSize || '32');
      t.setAttribute('font-weight', item.fontWeight || '700');
      t.setAttribute('font-family', item.fontFamily || 'Segoe UI, system-ui, sans-serif');
      if (item.transform) t.setAttribute('transform', item.transform);
      t.textContent = item.text;
      drawSvg.appendChild(t);
      drawHistory.push(t);
    } else if (item.type === 'dot') {
      // Parse the number from the label (e.g. "P3" -> 3) and track it
      const labelMatch = (item.label || '').match(/^P(\d+)$/);
      const pNum = labelMatch ? parseInt(labelMatch[1]) : getNextDotNumber();
      if (labelMatch) { usedDotNumbers.add(pNum); dotCounter = Math.max(dotCounter, pNum); }
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g._dotLabel = item.label || ('P' + pNum);
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', item.cx); c.setAttribute('cy', item.cy);
      c.setAttribute('r', item.r || '12');
      c.setAttribute('fill', item.fill || '#00d4ff');
      c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width', 2);
      c.setAttribute('opacity','0.9');
      g.appendChild(c);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', item.cx);
      t.setAttribute('y', parseFloat(item.cy) - parseFloat(item.r || 12) - 10);
      t.setAttribute('fill', '#00d4ff');
      t.setAttribute('font-size', item.fontSize || '28');
      t.setAttribute('font-weight','800');
      t.setAttribute('text-anchor','middle');
      t.setAttribute('font-family','Segoe UI, system-ui, sans-serif');
      t.setAttribute('paint-order','stroke');
      t.setAttribute('stroke','rgba(0,0,0,0.8)');
      t.setAttribute('stroke-width','4px');
      t.textContent = item.label || ('P' + pNum);
      g.appendChild(t);
      if (item.transform) g.setAttribute('transform', item.transform);
      drawSvg.appendChild(g);
      drawHistory.push(g);
    }
  });
  updateAnnoCount();
}

// ===== EDITABLE COORDINATES + SHARE =====
function applyCoordInputs() {
  const xVal = parseFloat(document.getElementById('coord-x').value);
  const yVal = parseFloat(document.getElementById('coord-y').value);
  const zVal = parseFloat(document.getElementById('coord-z').value);
  if (!isNaN(zVal) && zVal > 0) {
    scale = zVal / 100;
  }
  if (!isNaN(xVal) && !isNaN(yVal)) {
    const targetX = xVal / 100 * IW;
    const targetY = yVal / 100 * IH;
    px = mc.clientWidth / 2 - targetX * scale;
    py = mc.clientHeight / 2 - targetY * scale;
  }
  upd();
}

document.getElementById('coord-x').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); applyCoordInputs(); e.target.blur(); } e.stopPropagation(); });
document.getElementById('coord-y').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); applyCoordInputs(); e.target.blur(); } e.stopPropagation(); });
document.getElementById('coord-z').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); applyCoordInputs(); e.target.blur(); } e.stopPropagation(); });

// Share button ‚Äî copies a link with the current view encoded in the hash
document.getElementById('share-view-btn').onclick = () => {
  const r = mc.getBoundingClientRect();
  const centerSvgX = (r.width / 2 - px) / scale;
  const centerSvgY = (r.height / 2 - py) / scale;
  const xPct = (centerSvgX / IW * 100).toFixed(1);
  const yPct = (centerSvgY / IH * 100).toFixed(1);
  const z = scale.toFixed(3);
  const hash = `#v=${z},${xPct},${yPct}`;
  const url = window.location.origin + window.location.pathname + hash;
  navigator.clipboard.writeText(url).then(() => {
    toast('View link copied!');
  }).catch(() => {
    // Fallback
    window.location.hash = hash;
    toast('Link updated in address bar');
  });
};

// ===== SMOOTH ZOOM (animated transitions for button zoom) =====
function smoothZoom(targetScale, centerX, centerY) {
  const ns = Math.max(0.08, Math.min(12, targetScale));
  px = centerX - (centerX - px) * (ns / scale);
  py = centerY - (centerY - py) * (ns / scale);
  scale = ns;
  mw.classList.add('animating');
  upd();
  setTimeout(() => mw.classList.remove('animating'), 260);
}

// Override zoom button clicks with smooth version
document.getElementById('zi').onclick = () => {
  const cw = mc.clientWidth / 2, ch = mc.clientHeight / 2;
  smoothZoom(scale * 1.4, cw, ch);
};
document.getElementById('zo').onclick = () => {
  const cw = mc.clientWidth / 2, ch = mc.clientHeight / 2;
  smoothZoom(scale / 1.4, cw, ch);
};

// ===== KEYBOARD: add theme toggle key =====
const origKeydown = null; // We'll hook in below

// ===== INIT =====
buildLotList();
buildChips();
buildPtList();
updatePtStats();
updateRPVisibility();
// Apply shared view from URL hash (after image loads)
img.addEventListener('load', applyShareHash);
if (img.complete) setTimeout(applyShareHash, 100);
</script>
</body>
</html>
